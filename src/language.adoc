=== First steps with lisp syntax

Invented by John McCarthy in 1958, Lisp is one of the oldest programming languages that is still
around. It has evolved into a whole lot of derivatives called dialects and ClojureScript is
one of them. It's a programming language written in its own data structures, originally lists enclosed in
parenthesis, but Clojure(Script) has evolved the Lisp syntax with more data structures making
it more pleasant to write and read.

A list with a function in the first position is used for calling a function in ClojureScript:

[source, clojure]
----
(+ 1 2 3)
;; => 6
----

In the example above we're applying the addition function `+` to the arguments 1, 2 and 3. ClojureScript
allows many unusual characters like `?` or `-` in symbol names which makes it easier to read:

[source, clojure]
----
(zero? 0)
;; => true
----

For distinguishing function calls and lists, we can quote lists for turning off evaluation. The quoted
lists will be treat as data instead of as a function call:

[source, clojure]
----
'(+ 1 2 3)
;; => (+ 1 2 3)
----

ClojureScript uses more than lists for its syntax, the full details will be covered later but here is an
example of the usage of a vector (enclosed in brackets) for defining local bindings:

[source, clojure]
----
(let [x 1
      y 2
      z 3]
  (+ x y x))
;; => 6
----

This is practically all the syntax we need to know for using not only ClojureScript, but any Lisp. Being
written in its own data structures (often referred to as homoiconicity) is a great property since the syntax
is uniform and simple; also, code generation via macros is easier than in any language, giving us
plenty of power for extending the language to our needs.

=== The base data types.

The ClojureScript language has a rich set of data types like most programmig languages. It provides
scalar datatypes that will be very familiar for you such as numbers, strings, floats. But, also
provides a great amount of others that maybe are not well known such as symbols, keywords, regex,
vars, atoms, volatiles...

_ClojureScript_ embrases the host language, and as possible it uses the host provided types. In this
case: numbers and strings are used as is and them behaves in same way as in javascript.


==== Numbers

In _ClojureScript_ the numbers includes both: integers and floating points. But, knowing that
_ClojureScript_ is a guest language that compiles to javascript, having integers is an ilusion.
Because the javascript language treats all numbers as floating points values.

Like in any other languages, the numbers in _ClojureScript_ are represented in following way:

[source, clojure]
----
23
+23
-100
1.7
-2
33e8
12e-14
3.2e-4
----


==== Keywords

Keywords in _ClojureScript_ are objecs that always evaluate to themselves. Them are usually
used in map data structures for reprensent in a most efficient way to the keys.

[source, clojure]
----
:foobar
:2
:?
:foo/bar
----

As you can see, the keyword are all prefixed with `:`, but this char is only part
of literal syntax and is not part of the name of the object.

You also can create a keyword calling a function `keyword`. Do not worry if you do not understand
or something is not clear in the following example, the functions are discussed some chapters
below.

[source, clojure]
----
(keyword "foo")
;; => :foo
----


==== Symbols

The symbols in _ClojureScript_ are very very similar to now known *Keywords*. But them
instead of evaluating to themselves, are evalutated to something that them refers, that
can be function, variables, ...

Them are represented with something that not star with a number

[source, clojure]
----
sample-symbol
othersymbol
f1
----

Do not worry if you do not understand clearly this part, symbols are used un almost
all examples and you will have the oportunity to undesarstand them in a practical way,
with examples.


==== Strings

Nothing new we can explain about strings that you do not known. In _ClojureScript_ them
are work like in any other language. Them are immutable.

And in this concrete case are the same as in javascript:

[source, clojure]
----
"A example of a string"
----

The pecularity of Strings on _ClojureScript_ is due to lisp syntax, and is that you don't need
additional syntax for multiline strings:

[source, clojure]
----
"This is a multiline
      string in ClojureScript."
----

==== Characters

_ClojureScript_ also has a representation for one character and it has a literal syntax for represent
them.

[source, clojure]
----
\a        ; The lowercase a character
\newline  ; The new line character
----

As its host does not a clear representation for character type, in _ClojureScript_ behind the scenes
one character is a simple string with one character.


==== Collections

As usual, the second big step on explaining one language, is explain its collections and collection
abstractions. The _ClojureScript_ is not an exception in this rule.

_ClojureScript_ comes with great bunch of different collections. The main difference of _ClojureScript_
collections with other languages is that them are persistent and immutable.

But before venture of all these (maybe) unknown concepts, we'll go to make a high level overview
of existing collection types in _ClojureScript_.


===== Lists

This is a clasic collection type in lisp languages. _ClojureScript_ is not an exception. List is the
simplest collection data structure in _ClojureScript_. Lists can contain items of any type, including
other collections.

Lists in _ClojureScript_ are repsesented with parentheses as its literal syntax:

[source, clojure]
----
'(1 2 3 4 5)
'(:foo :bar 2)
----

As you can observe, all list examples are prefixed with `'` char. This is because lists in lisp like
languages are often used for express expressions forms such as function or macro calls. In that case
the first item should be a symbol that will evaluate to a something callable and the rest of list
elemenents will be a function parameters.

[source, clojure]
----
(inc 1)
;; => 2

'(inc 1)
;; => (inc 1)
----

As you see, if you will evaluate the `(inc 1)` without prefixing it with `'` char, it will resolve
the `inc` symbol to the *inc* function and will execute it with `1` as first parameter. Resulting
in a `2` as return value.

Lists have the pecularity that they are very efficient if you access to it in a sequence mode or
access to its first elements but are not very good option if you need random (index) acces to its
elements.


===== Vectors

Like lists, *Vectors*  store a series of values, but in this case with very efficient index access
to its elements and its elements in difference with list are evaluated in order. Do not worry, in
below chapters we'll go depth in details but at this moment is more that enough.

Vectors uses square brakets for the literal syntax, let see some examples:

[source, clojure]
----
[:foo :bar]
[3 4 5 nil]
----

Like lists, vectors can contain objects of any type, as you can observe the previos example.


===== Maps

Maps is a collection abstraction that allows store unique keys associated with one value. In other
languages are commonly known as hash-maps or dicts. Maps in _ClojureScript_ uses a
curly braces as literal syntax.

[source, clojure]
----
{:foo "bar", :baz 2}
{:foobar [:a :b :c]}
----

NOTE: Commas are frequently used for separate a key value pair but are completelly optional. In
_ClojureScript_ syntax, comas are treated like spaces.

Like Vectors, every item in a map literal is evaluated before the result is stored in a map, but
the order of evaluation is not guaranteed.


===== Sets

And finally, *Sets*.

Sets stores in an unordered way zero or more unique items of any type. They,
like maps, uses curly braces for its literal syntax with difference that uses a `#` as leading
character:

[source, clojure]
----
#{1 2 3 :foo :bar}
----

In below chapters we'll go depth in sets and other collection types explained in this chapter.


=== Vars

_ClojureScript_ is a mostly functional language and focused in immutability. Becuase of that, it does
not has the concept of variables. The most closest analogy to variables are *vars*. The vars are
represented by symbols and stores a single value together with metadata.

You can define a var using a `def` special form:

[source, clojure]
----
(def x 22)
(def y [1 2 3])
----

The vars are always top level in the namespace. If you use `def` in a function call, the var will be defined
at the namespace level.


=== Functions

==== The first contact

It's time of make things happen. In _ClojureScript_, a function are first-class type. It behaves
like any other type, you can pass it as parameter, you can return it as value, always respecting
the lexical scope. _ClojureScript_ also has some features from dynamic scope but this will be discused
in other section.

If you want know more about scopes, this link:http://en.wikipedia.org/wiki/Scope_%28computer_science[wikipedia article]
is ver extensive and explain very well different types of scope.

As _ClojureScript_ is a lisp dialect, it uses the prefix notation for calling a function:

[source, clojure]
----
(inc 1)
;; => 2
----

The `inc` is a function and is part of _ClojureScript_ runtime, and `1` is a first positional
argument for the `inc` function.

[source, clojure]
----
(+ 1 2 3)
;; => 6
----

The `+` symbol represents a `add` function, in ALGOL type of languages is an operator and only
allows two parameters.

The prefix notation has huge advantages, some of them not alwats obvious. _ClojureScript_ does not
has distinction between a function and operator, everything is a function. The inmediate advantage
is that the prefix notation allows an arbitrary number of arguments per "operator". Also, it eliminates
per complete the problem of operator precedence.


==== Defining own functions

The function can be defined with `fn` special form. This is aspect of function definition:

[source, clojure]
----
(fn [param1 param2]
  (+ (inc param1) (inc param2)))
----

You can define a function and call it in same time (in a single expression):

[source, clojure]
----
((fn [x] (inc x)) 1)
;; => 2
----

Let start creating named functions. But that is means named function really? Is very simple,
as in _ClojureScript_ functions are fist-class and behaves like any other value, naming a function
is just store it in a var:

[source, clojure]
----
(def myinc (fn [x] (+ x 1)))

(myinc 1)
;; => 2
----

_ClojureScript_ also offers the `defn` macro as a little sugar syntax for make function definition
more idiomatic:

[source, clojure]
----
(defn myinc
  "Self defined version of `inc`."
  [x]
  (+ x 1))
----


==== Function with multiple arities

_ClojureScript_ also comes with ability to define functions with arbitrary number of arities. The
syntax is almost the same as define standard function with the difference that it has more that
one body.

Let see an example, surelly it will explain it much better:

[source, clojure]
----
(defn myinc
  "Self dined version of parametrized `inc`."
  ([x] (myinc x 1))
  ([x increment]
   (+ x increment)))
----

And there some examples using the previously defined multi arity function. I can observe that
if you call a function with wrong number of parameters the compiler will emit an error about that:

[source, clojure]
----
(myinc 1)
;; => 1

(myinc 1 3)
;; => 4

(myinc 1 3 3)
;; Compiler error
----

[NOTE]
Explaining the "arity" is out of scope of this book, however you can read about that in this
link:http://en.wikipedia.org/wiki/Arity[wikipedia article].


==== Variadic functions

An other way to accept multiple parameters is defining variadic functions. Variadic functions
are functions that will be able accept arbitrary number of arguments:

[source, clojure]
----
(defn my-variadic-set
  [& params]
  (set params))

(my-variadic-set 1 2 3 1)
;; => #{1 2 3}
----

The way to denone a variadic function is using the `&` simbol prefix on its arguments vector.


==== Short syntax for anonymous functions

_ClojureScript_ provides a shorter syntax for define anonymos (and almost always one liner) functions
using the `#()` reader macro. Reader macros are "special" expressions that in compile time will be
transformed to the apropiate language form. In this case to some expression that uses `fn` special
form.

[source, clojure]
----
(def my-set #(set %1 %2))

(my-set 1 2)
;; => #{1 2}
----

The `%1`, `%2`, `%N` are simple markers for parameter positions that are implicitly declared when
the reader macro will be interpreted and converted to `fn` expression.

Also, if a function only accepts one argument, you can ommit the number after `%` symbol, the
function `#(set %1)` can be written `++#++(set %)`.

Additionaly, this syntax also supports the variadic form with `%&` symbol:

[source, clojure]
----
(def my-variadic-set #(set %&))

(my-variadic-set 1 2 2)
;; => #{1 2}
----


=== Flow control

_ClojureScript_ has a great different approaches for flow control.


==== Branching with `if`

Let start with a basic one: `if`. In _ClojureScript_ the `if` is an expression and not an
statement, and it has three parametes: first one the condition expression, the second one
a expression that will evalute if a condition expression will evalute in a logical true,
and the third one will evaluated otherwise.

[source, clojure]
----
(defn mypos?
  [x]
  (if (pos? x)
    "positive"
    "negative"))

(mypos? 1)
;; => "positive"

(mypos? -1)
;; => "negative"
----

If you want do more that one thing in one of two expressions, you can use block expression `do`, that
is will explained in next section.


==== Branching with `cond`

Sometimes, the `if` expression can be slightly limited because it does not have the "else if" part
for add more that one condition. The cond comes to the rescue.

With `cond` expression, you can define multiple conditions:

[source, clojure]
----
(defn mypos?
  [x]
  (cond
    (> x 0) "positive"
    (< x 0) "negative"
    :else "zero"))

(mypos? 0)
;; => "zero"

(mypos? -2)
;; => "negative"
----

Also, cond has an other form, called `condp`, that works very similar to the simple `cond`
but looks more cleaner when a predicate is always the same for all conditions:

[source, clojure]
----
(defn translate-lang-code
  [code]
  (condp = (keyword code)
    :es "Spanish"
    :en "English"
    "Unknown"))

(translate-lang-code "en")
;; => "English"

(translate-lang-code "fr")
;; => "Unknown"
----


==== Branching with `case`

The `case` branching expression has very similar use case that our previous example with
`condp`. The main difference is that, case always uses the `=` predicate/function and its
branching values are evaluated at compile time. This results in a more prerformant form
that `cond` or `condp` but has the disadvantage of that the condition value should be
a static value.

Let see the same example as previous one but using `case`:

[source, clojure]
----
(defn translate-lang-code
  [code]
  (case code
    "es" "Spanish"
    "es" "English"
    "Unknown"))

(translate-lang-code "en")
;; => "English"

(translate-lang-code "fr")
;; => "Unknown"
----


=== Locals, Blocks and Loops

==== Locals

_ClojureScript_ does not has the variables concepts, but it does have locals. Locals as per
usual, are immutable and if you try mutate them, the compiller will throw an error.

The locals are defined with `let` expression. It starts with a vector as first parameter
followed by arbitrary number of expresions. The first parameter should contain a arbitrary
number of pairs that starts with a binding form followed of an expression whose value will
be bound to this new local for the remainer of the let expression.

[source, clojure]
----
(let [x (inc 1)
      y (+ x 1)]
  (println "Simple message from body of let")
  (* x y))
;; => 6
----

==== Blocks

The blocks in _ClojureScript_ can be done using the `do` expression and is ususally used
for side effects, like printing something in console or write a log in a logger. Something
for that the return value is not necesary.

The `do` expression accept as parameter an arbitrary number of other expressions but return
the return value only from the last one:

[source, clojure]
----
(do
   (println "hello world")
   (println "hola mundo")
   (+ 1 2))
;; => 3
----

The `let` expression, explained just in previous section, the body is very similar to the
`do` expression. In fact, it is called that is has an implicit `do`.


==== Loops

The functional approach of _ClojureScript_, this causes that it does not have standard,
well known statements based loops. The loops in clojurescript are handled using recursion.
The recursion sometimes requires additional thinking about how model your problem in
a slightly different way than imperative languages.

Also, many of the common patterns for which `for` is used in other languages are achieved
through higher-order functions.


===== Looping with loop/recur

Let's take a look at how to express loops using recursions with the `loop` and `recur` forms.
`loop` defines a possibly empty list of bindings (notice the symmetry with `let`) and `recur`
jumps execution after the looping point with new values for those bindings.

Let's see an example:

[source, clojure]
----
(loop [x 0]
   (println "Looping with " x)
   (if (= x 2)
     (println "Done looping!")
     (recur (inc x))))
;; => "Looping with 0"
;; => "Looping with 1"
;; => "Looping with 2"
;; => "Done looping!"
----

In the above snippet, we bind the name `x` to the value `0` and execute the body. Since the
condition is not met the first time is run we `recur`, incrementing the binding value with
the `inc` function. We do this once more until the condition is met and, since there aren't
more `recur` calls, exit the loop.

Note that `loop` isn't the only point we can `recur` too, using `recur` inside a function
executes the body of the function recursively with the new bindings:

[source, clojure]
----
(defn recursive-function [x]
   (println "Looping with" x)
   (if (= x 2)
     (println "Done looping!")
     (recur (inc x))))

(recursive-function 0)
;; => "Looping with 0"
;; => "Looping with 1"
;; => "Looping with 2"
;; => "Done looping!"
----


===== Replacing for loops with higher-order functions

In imperative programming languages is common to use `for` loops for iterating over data and
transforming it, usually the intent being one of the following:

- Transform every value in the iterable yielding another iterable
- Filter the elements of the iterable by a certain criteria
- Convert the iterable to a value where each iteration depends on the result from the previous one
- Run a computation for every value in the iterable

The above actions are encoded in higher-order functions and syntactic constructs in ClojureScript,
let's see an example of the first three.

For transforming every value in a iterable data structure we use the `map` function, which takes a
function and a sequence and applies the function to every element:

[source, clojure]
----
(map inc [0 1 2])
;; => (1 2 3)
----

For filtering the values of a data structure we use the `filter` function, which takes a predicate
and a sequence and gives a new sequence with only the elements that returned `true` for the given
predicate:

[source, clojure]
----
(filter odd? [1 2 3 4])
;; => (1 3)
----

Converting an iterable to a value accumulating the intermediate result in every step of the iteration
can be achieved with `reduce`, which takes a function for accumulating values, an optional initial value
and a collection:

[source, clojure]
----
(reduce + 0 [1 2 3 4])
;; => 10
----


===== `for` sequence comprehensions

In ClojureScript the `for` construct isn't used for iteration but for generating sequences, an operation
also known as "sequence comprehension". It offers a small domain specific language for declaratively
building lazy sequences.

It takes a vector of bindings and a expression and generates a sequence of the result of evaluating the
expression, let's take a look at an example:

[source, clojure]
----
(for [x [1 2 3]]
  [x x])
;; => ([1 1] [2 2] [3 3])
----

It supports multiple bindings, which will cause the collections to be iterated in a nested fashion, much
like nesting `for` loops in imperative languages:

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]]
  [x y])
;; => ([1 4] [1 5] [2 4] [2 5] [3 4] [3 5])
----

We can also follow the bindings with three modifiers: `:let` for creating local bindings, `:while` for
breaking out of the sequence generation and `:when` for filtering out values.

Here's an example of local bindings using the `:let` modifier, note that the bindings defined with it
will be available in the expression:

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]]
  z)
;; => (5 6 6 7 7 8)
----

We can use the `:while` modifier for expressing a condition that, when it is no longer met, will stop
the sequence generation. Here's an example:

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :while (= y 4)]
  [x y])
;; => ([1 4] [2 4] [3 4])
----

For filtering out generated values we use the `:when` modifier like in the following example:

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :when (= (+ x y) 6)]
  [x y])
;; => ([1 5] [2 4])
----

We can combine the modifiers shown above for expressing complex sequence generations or
more clearly expressing the intent of our comprehension:

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]
      :when (= z 6)]
  [x y])
;; => ([1 5] [2 4])
----

When we outlined the most common usages of the `for` construct in imperative programming languages
we mentioned that sometimes we want to run a computation for every value in a sequence, not caring
about the result. Presumably we do this for achieving some sort of side-effect with the values of
the sequence.

ClojureScript provides the `doseq` construct, which is analogous to `for` but executes the expression
discarding the resulting values and returns `nil`.

[source, clojure]
----
(doseq [x [1 2 3]
        y [4 5]
       :let [z (+ x y)]]
  (println x "+" y "=" z))
;; => "1 + 4 = 5"
;; => "1 + 5 = 6"
;; => "2 + 4 = 6"
;; => "2 + 5 = 7"
;; => "3 + 4 = 7"
;; => "3 + 5 = 8"
;; => nil
----


=== Collection types


==== Immutable and persistent

We mentioned before that ClojureScript collections are persistent and immutable but didn't explain what
we meant.

An immutable data structure, as its name suggest, is a data structure that can not be changed. In-place
updates are not allowed in immutable data structures.

A persistent data structure is a data structure that returns a new version of itself when transforming
it, leaving the original unmodified. ClojureScript makes this memory and time efficient using an
implementation technique called structural sharing, where most of the data shared between two versions
of a value is shared and transformations of a value are implemented by copying the minimal amount of data
required.

Let's see an example of appending values to a vector using the `conj` (for "conjoin") operation:

[source, clojure]
----
(let [xs [1 2 3]
      ys (conj xs 4)]
  (println "xs:" xs)
  (println "ys:" ys))
;; => xs: [1 2 3]
;; => ys: [1 2 3 4]
;; => nil
----

As you can see, we derived a new version of the `xs` vector appending an element to it and got a new
vector `ys` with the element added.

For illustrating the structural sharing of ClojureScript data structures, let's compare whether some parts
of the old and new versions of a data structure are actually the same object with the `identical?` predicate.
We'll use the list data type for this purpose:

[source, clojure]
----
(let [xs (list 1 2 3)
      ys (cons 0 xs)]
  (println "xs:" xs)
  (println "ys:" ys)
  (println "(rest ys):" (rest ys))
  (identical? xs (rest ys)))
;; => xs: (1 2 3)
;; => ys: (0 1 2 3)
;; => (rest ys): (1 2 3)
;; => true
----

As you can see in the example, we used `cons` (construct) to prepend a value to the `xs` list and we got
a new list `ys` with the element added. The `rest` of the `ys` list (all the values but the first)
are the same object in memory that the `xs` list, thus `xs` and `ys` share structure.


==== The sequence abstraction


//^ All about collection types, immutability, persistence, seq abstraction...


==== Collections in depth

===== Lists
===== Vectors
===== Maps
===== Sets

=== Destructuring

TBD


=== Namespaces

==== Defining a namespace

Namespaces is a clojurescript's fundamental unit of code modularity. Are analogous to Java packages or
Ruby and Python modules, and can be defined with `ns` macro. Maybe if you are touched a little bit of
clojurescript source you have seen something like this at begining of the file:

[source, clojure]
----
(ns myapp.core
  "Some docstring for the namespace.")

(def x "hello")
----

Namespaces are dynamic and you can create one in any time, but the convention is having one namespace
per file. So, the namespace definition usually is at begining of the file followed with optional
docstring.

Previously we have explained the vars and symbols. Every var that you are defines will be associated
with one namespace. If you do not define a concrete namespace, the default one called "user" will be
used:

[source, clojure]
----
(def x "hello")
;; => #'user/x
----

==== Loading other namespaces

It's ok, definining a namespace and vars in it is really easy, but it is not very usefull if we can't
use them from other namespaces. For this purpose, the `ns` macro also offers a simple way to load other
namespaces.

Observe the following:

[source, clojure]
----
(ns myapp.main
  (:require myapp.core
            clojure.string))

(clojure.string/upper-case myapp.core/x)
;; => "HELLO"
----

As you can observe, we are using fully qualified names (namespace + var name) for access to vars and
functions from different namespaces.

It is ok, we not can access to other namespaces but is very boring always write the complete namespace
name for access to its vars and functions. It will be specially uncomfortable if a namespace name
is very large. For solve that, you can use the `:as` directive for create an additional (usually
more shorter) alias to the namespace. Let see the how it can be done:

[source, clojure]
----
(ns myapp.main
  (:require [myapp.core :as core]
            [clojure.string :as str]))

(str/upper-case core/x)
;; => "HELLO"
----

Additionaly, _ClojureScript_ offers a simple way to refer specific vars or functions from concrete namespace using the `:refer` directive.

The `:refer` directive has two possible arguments: `:all` keyword or a vector of symbols that will
refer to vars in the namespace. With `:all` we are indicating that we want refer all public vars from the
namespace and with vector we can specify the concrete subset of vars that we want.

[source, clojure]
----
(ns myapp.main
  (:require [myapp.core :refer :all]
            [clojure.string :refer [upper-case]]))
----

And finally, we should know that everything that located in the `cljs.core` namespace is automatically
loaded and you should not require it explicitly. But sometimes you want declare vars that will clash
with some other defined in `cljs.core` namespace. For it, the `ns` macro offers an other directive that
allows exclude concrete symbols and prevet them to be automaticaly loaded.

Observe the following:

[source, clojure]
----
(ns myapp.main
  (:refer-clojure :exclude [min]))

(defn min
  [x y]
  (if (> x y)
    y
    x))
----

The `ns` macro also has other directives for loading host clases (`:import`) and macros
(`:refer-macros`), but them are explained in posterior sections.


=== Abstractions and Polymorphism

==== Multimethods

TBD


==== Protocols

TBD


=== Data types

Until, now, we have used maps, sets, lists and vectors for represent our data. And in most cases is a
really great aproach for do it. But some times we need define our own types and in this book we will
call them *datatypes*.

A datatype provides the following:

* A unique host backed type, either named or anonymous.
* Explicitly declared structure using fields or closures.
* Implement concrete abstractions.
* Map like behavior (via records, see below).


==== Deftype

The most low level construction in _ClojureScript_ for create own types, is the `deftype` macro. For
demostration we will define a type called `User`:

[source, clojure]
----
(deftype User [firstname lastname])
----

Once the type has beed defined, we can create an instance of our `User`:

[source, clojure]
----
(def user (User. "Triss" "Merigold"))
----

And its fields can be accesset using the prefix-dot notation:

[source, clojure]
----
(.-firstname user)
;; => "Triss"
----

Types defined with deftype (and posteriory with defrecord) creates a host backed class like object
associated to the current namespace. But it has some peculiarities when we intend to use or import
it from other namespace. The types in _ClojureScript_ should be imported with `:import` directive
of `ns` macro:

[source, clojure]
----
(ns myns.core
  (:import otherns.User))

(User. "Cirilla" "Fiona")
----

For convenience, _ClojureScript_ also defines a constructor function caled `->User` that can be imported
with the common way using `:require` directive.

We personally do not like this type of functions, and we prefer define own constructors, with more
idiomatic names:

[source, clojure]
----
(defn user
  [firstname lastname]
  (User. firstname lastname))
----

And use it in our code instead of `->User`.


==== Defrecord

The record is a slightly higher level abstraction for define types in _ClojureScript_ and should be
prefered way to do it.

As we know, _ClojureScript_ tends to use plain data types how are the maps but in most cases we need
have a named type for represent the entities of our application. Here come the records.

A record is a datatype that implements a map protocols and therefore can be used like any other map.
And since records are also proper types, they support type-based polymorphism through protocols.

In summary: with records, we have the best of both worlds, maps that can play in in different
abstractions.

Let start defining the `User` type but using records:

[source, clojure]
----
(defrecord User [firstname lastname])
----

It looks really similar to deftype syntax, in fact, it uses deftype behind the scenes as low level
primitive for defining types.

Now, look the difference with raw types for access to its fields:

[source, clojure]
----
(def user (User. "Yennefer" "of Vengerberg"))

(:username user)
;; => "Yennefer"

(get user :username)
;; => "Yennefer"
----

As we mention previously, records are maps and acts like tham:

[source, clojure]
----
(map? user)
;; => true
----

And like maps, tham support extra fields that are not initially defined:

[source, clojure]
----
(def user2 (assoc user :age 92))

(:age user2)
;; => 92
----

As we can see, the `assoc` function works as is expected and return a new instance of the same
type but with new key value pair. But take care with `dissoc`, its behavior with records is slightly
different that with maps; it will return a new record if the field being dissociated is an optional
field, but it will return a plain map if you dissociate the mandatory field.

An other difference with maps is that records does not acts like functions:

[source, clojure]
----
(def plain-user {:username "Yennefer", :lastname "of Vengerberg"})

(plain-user :username)
;; => "Yennefer"

(user :username)
;; => user.User does not implements IFn protocol.
----

The `defrecord` macro like the `deftype`, for convenience esposes `->User` function, but with additional
one `map->User` constructor function. We have the same opionon about that constructors that with
deftype defined ones: we recommend define own instead of use that ones. But as they exists, let see
how they can be used:

[source, clojure]
----
(def cirilla (->User "Cirilla" "Fiona"))
(def yen (map->User {:firstname "Yennefer"
                     :lastname "of Vengerberg"}))
----


==== Implement protocols

Both type definition primitives that we have seen until now allows inline implementations for protocols
(explained in previous section). Let start define one for example purposes:

[source, clojure]
----
(defprotocol IUser
  "A common abstraction for work with user types."
  (full-name [_] "Get the full name of the user."))
----

NOTE: the "I" prefix is very common for make clear separation of protocols and types. In clojute
comunity it there many dispare optionions about the "I" prefix. In our opinion is an acceptable
solution for avoid name clashing and confusions. (TODO: move this note to the previous section)

Now, you can define a type with inline implementation for an abstraction, in our case the `IUser`:

[source, clojure]
----
(defrecord User [firstname lastname]
  IUser
  (full-name [_]
    (str firstname " " lastname)))

;; Create an instance.
(def user (User. "Yennefer" "of Vengerberg"))

(full-name user)
;; => "Yennefer of Vengerberg"
----


==== Reify

The `reify` macro lets you create an anonymous types that implement protocols. In difference with
deftype and defrecord, it does not has accessible fields.

This is a way how we can emulate an instance of user type and that plays well in `IUser` abstraction:

[source, clojure]
----
(defn user
  [firstname lastname]
  (reify
    IUser
    (full-name [_]
      (str firstname " " lastname))))

(def yen (user "Yennefer" "of Vengerberg"))
(full-name user)
;; => "Yennefer of Vengerberg"
----

The real purpose of reify is create anonymous types that plains in a concrete abstractions but
you do not want a type in self.


=== Host interoperability

TBD


=== State management

TBD


=== Mutability

TBD


=== A little overview of macros

TBD


=== Truthiness

TBD