=== First steps with lisp syntax

Invented by John McCarthy in 1958, Lisp is one of the oldest programming languages that is still
around. It has evolved into a whole lot of derivatives called dialects and ClojureScript is
one of them. It's a programming language written in its own data structures, originally lists enclosed in
parenthesis, but Clojure(Script) has evolved the Lisp syntax with more data structures making
it more pleasant to write and read.

A list with a function in the first position is used for calling a function in ClojureScript:

[source, clojure]
----
(+ 1 2 3)
;; => 6
----

In the example above we're applying the addition function `+` to the arguments 1, 2 and 3. ClojureScript
allows many unusual characters like `?` or `-` in symbol names which makes it easier to read:

[source, clojure]
----
(zero? 0)
;; => true
----

For distinguishing function calls and lists, we can quote lists for turning off evaluation. The quoted
lists will be treat as data instead of as a function call:

[source, clojure]
----
'(+ 1 2 3)
;; => (+ 1 2 3)
----

ClojureScript uses more than lists for its syntax, the full details will be covered later but here is an
example of the usage of a vector (enclosed in brackets) for defining local bindings:

[source, clojure]
----
(let [x 1
      y 2
      z 3]
  (+ x y x))
;; => 6
----

This is practically all the syntax we need to know for using not only ClojureScript, but any Lisp. Being
written in its own data structures (often referred to as homoiconicity) is a great property since the syntax
is uniform and simple; also, code generation via macros is easier than in any language, giving us
plenty of power for extending the language to our needs.

=== The base data types.

The ClojureScript language has a rich set of data types like most programmig languages. It provides
scalar datatypes that will be very familiar for you such as numbers, strings, floats. But, also
provides a great amount of others that maybe are not well known such as symbols, keywords, regex,
vars, atoms, volatiles...

_ClojureScript_ embrases the host language, and as possible it uses the host provided types. In this
case: numbers and strings are used as is and them behaves in same way as in javascript.


==== Numbers

In _ClojureScript_ the numbers includes both: integers and floating points. But, knowing that
_ClojureScript_ is a guest language that compiles to javascript, having integers is an ilusion.
Because the javascript language treats all numbers as floating points values.

Like in any other languages, the numbers in _ClojureScript_ are represented in following way:

[source, clojure]
----
23
+23
-100
1.7
-2
33e8
12e-14
3.2e-4
----


==== Keywords

Keywords in _ClojureScript_ are objecs that always evaluate to themselves. Them are usually
used in map data structures for reprensent in a most efficient way to the keys.

[source, clojure]
----
:foobar
:2
:?
:foo/bar
----

As you can see, the keyword are all prefixed with `:`, but this char is only part
of literal syntax and is not part of the name of the object.

You also can create a keyword calling a function `keyword`. Do not worry if you do not understand
or something is not clear in the following example, the functions are discussed some chapters
below.

[source, clojure]
----
(keyword "foo")
;; => :foo
----


==== Symbols

The symbols in _ClojureScript_ are very very similar to now known *Keywords*. But them
instead of evaluating to themselves, are evalutated to something that them refers, that
can be function, variables, ...

Them are represented with something that not star with a number

[source, clojure]
----
sample-symbol
othersymbol
f1
----

Do not worry if you do not understand clearly this part, symbols are used un almost
all examples and you will have the oportunity to undesarstand them in a practical way,
with examples.


==== Strings

Nothing new we can explain about strings that you do not known. In _ClojureScript_ them
are work like in any other language. Them are immutable.

And in this concrete case are the same as in javascript:

[source, clojure]
----
"A example of a string"
----

The pecularity of Strings on _ClojureScript_ is due to lisp syntax, and is that you don't need
additional syntax for multiline strings:

[source, clojure]
----
"This is a multiline
      string in ClojureScript."
----

==== Characters

_ClojureScript_ also has a representation for one character and it has a literal syntax for represent
them.

[source, clojure]
----
\a        ; The lowercase a character
\newline  ; The new line character
----

As its host does not a clear representation for character type, in _ClojureScript_ behind the scenes
one character is a simple string with one character.


==== Collections

As usual, the second big step on explaining one language, is explain its collections and collection
abstractions. The _ClojureScript_ is not an exception in this rule.

_ClojureScript_ comes with great bunch of different collections. The main difference of _ClojureScript_
collections with other languages is that them are persistent and immutable.

But before venture of all these (maybe) unknown concepts, we'll go to make a high level overview
of existing collection types in _ClojureScript_.


===== Lists

This is a clasic collection type in lisp languages. _ClojureScript_ is not an exception. List is the
simplest collection data structure in _ClojureScript_. Lists can contain items of any type, including
other collections.

Lists in _ClojureScript_ are repsesented with parentheses as its literal syntax:

[source, clojure]
----
'(1 2 3 4 5)
'(:foo :bar 2)
----

As you can observe, all list examples are prefixed with `'` char. This is because lists in lisp like
languages are often used for express expressions forms such as function or macro calls. In that case
the first item should be a symbol that will evaluate to a something callable and the rest of list
elemenents will be a function parameters.

[source, clojure]
----
(inc 1)
;; => 2

'(inc 1)
;; => (inc 1)
----

As you see, if you will evaluate the `(inc 1)` without prefixing it with `'` char, it will resolve
the `inc` symbol to the *inc* function and will execute it with `1` as first parameter. Resulting
in a `2` as return value.

Lists have the pecularity that they are very efficient if you access to it in a sequence mode or
access to its first elements but are not very good option if you need random (index) acces to its
elements.


===== Vectors

Like lists, *Vectors*  store a series of values, but in this case with very efficient index access
to its elements and its elements in difference with list are evaluated in order. Do not worry, in
below chapters we'll go depth in details but at this moment is more that enough.

Vectors uses square brakets for the literal syntax, let see some examples:

[source, clojure]
----
[:foo :bar]
[3 4 5 nil]
----

Like lists, vectors can contain objects of any type, as you can observe the previos example.


===== Maps

Maps is a collection abstraction that allows store unique keys associated with one value. In other
languages are commonly known as hash-maps or dicts. Maps in _ClojureScript_ uses a
curly braces as literal syntax.

[source, clojure]
----
{:foo "bar", :baz 2}
{:foobar [:a :b :c]}
----

NOTE: Commas are frequently used for separate a key value pair but are completelly optional. In
_ClojureScript_ syntax, comas are treated like spaces.

Like Vectors, every item in a map literal is evaluated before the result is stored in a map, but
the order of evaluation is not guaranteed.


===== Sets

And finally, *Sets*.

Sets stores in an unordered way zero or more unique items of any type. They,
like maps, uses curly braces for its literal syntax with difference that uses a `#` as leading
character:

[source, clojure]
----
#{1 2 3 :foo :bar}
----

In below chapters we'll go depth in sets and other collection types explained in this chapter.


=== Vars

_ClojureScript_ is a mostly functional language and focused in immutability. Becuase of that, it does
not has the concept of variables. The most closest analogy to variables are *vars*. The vars are
represented by symbols and stores a single value together with metadata.

You can define a var using a `def` special form:

[source, clojure]
----
(def x 22)
(def y [1 2 3])
----

The vars are always top level in the namespace. If you use `def` in a function call, the var will be defined
at the namespace level.


=== Functions

==== A little introduction

It's time of make things happen. In _ClojureScript_, a function are first-class type. It behaves
like any other type, you can pass it as parameter, you can return it as value, always respecting
the lexical scope. _ClojureScript_ also has some features from dynamic scope but this will be discused
in other section.

If you want know more about scopes, this link:http://en.wikipedia.org/wiki/Scope_%28computer_science[wikipedia article]
is ver extensive and explain very well different types of scope.

As _ClojureScript_ is a lisp dialect, it uses the prefix notation for calling a function:

[source, clojure]
----
(inc 1)
;; => 2
----

The `inc` is a function and is part of _ClojureScript_ runtime, and `1` is a first positional
argument for the `inc` function.

[source, clojure]
----
(+ 1 2 3)
;; => 6
----

The `+` symbol represents a `add` function, in ALGOL type of languages is an operator and only
allows two parameters.

The prefix notation has huge advantages, some of them not alwats obvious. _ClojureScript_ does not
has distinction between a function and operator, everything is a function. The inmediate advantage
is that the prefix notation allows an arbitrary number of arguments per "operator". Also, it eliminates
per complete the problem of operator precedence.

==== Defining own functions

The function can be defined with `fn` special form. This is aspect of function definition:

[source, clojure]
----
(fn [param1 param2]
  (+ (inc param1) (inc param2)))
----

You can define a function and call it in same time (in a single expression):

[source, clojure]
----
((fn [x] (inc x)) 1)
;; => 2
----

Let start creating named functions. But that is means named function really? Is very simple,
as in _ClojureScript_ functions are fist-class and behaves like any other value, naming a function
is just store it in a var:

[source, clojure]
----
(def myinc (fn [x] (+ x 1)))

(myinc 1)
;; => 2
----

_ClojureScript_ also offers the `defn` macro as a little sugar syntax for make function definition
more idiomatic:

[source, clojure]
----
(defn myinc
  "Self defined version of `inc`."
  [x]
  (+ x 1))
----

==== Function with multiple arities

_ClojureScript_ also comes with ability to define functions with arbitrary number of arities. The
syntax is almost the same as define standard function with the difference that it has more that
one body.

Let see an example, surelly it will explain it much better:

[source, clojure]
----
(defn myinc
  "Self dined version of parametrized `inc`."
  ([x] (myinc x 1))
  ([x increment]
   (+ x increment)))
----

And there some examples using the previously defined multi arity function. I can observe that
if you call a function with wrong number of parameters the compiler will emit an error about that:

[source, clojure]
----
(myinc 1)
;; => 1

(myinc 1 3)
;; => 4

(myinc 1 3 3)
;; Compiler error
----

[NOTE]
Explaining the "arity" is out of scope of this book, however you can read about that in this
link:http://en.wikipedia.org/wiki/Arity[wikipedia article].


==== Variadic functions

An other way to accept multiple parameters is defining variadic functions. Variadic functions
are functions that will be able accept arbitrary number of arguments:

[source, clojure]
----
(defn my-variadic-set
  [& params]
  (set params))

(my-variadic-set 1 2 3 1)
;; => #{1 2 3}
----

The way to denone a variadic function is using the `&` simbol prefix on its arguments vector.


=== Loops and blocks

TBD


=== Collection types.

TBD

//^ All about collection types, immutability, persistence, seq abstraction...


=== Destructuring

TBD


=== Namespaces

TBD


=== Data types

TBD


=== Polymorphism & Polymorphic constructions

TBD


=== Host interoperability

TBD


=== A little overview of macros

TBD