=== First steps with Lisp syntax

Invented by John McCarthy in 1958, Lisp is one of the oldest programming languages that is still
around. It has evolved into many derivatives called dialects, and ClojureScript is
one of them. It's a programming language written in its own data structures, originally lists enclosed in
parentheses, but Clojure(Script) has evolved the Lisp syntax with more data structures, making
it more pleasant to write and read.

A list with a function in the first position is used for calling a function in ClojureScript:

[source, clojure]
----
(+ 1 2 3)
;; => 6
----

In the example above, we're applying the addition function `+` to the arguments 1, 2 and 3. ClojureScript
allows many unusual characters like `?` or `-` in symbol names, which makes it easier to read:

[source, clojure]
----
(zero? 0)
;; => true
----

For distinguishing function calls and lists, we can quote lists to keep them from being evaluated. The quoted
lists will be treated as data instead of as a function call:

[source, clojure]
----
'(+ 1 2 3)
;; => (+ 1 2 3)
----

ClojureScript uses more than lists for its syntax. The full details will be covered later, but here is an
example of the usage of a vector (enclosed in brackets) for defining local bindings:

[source, clojure]
----
(let [x 1
      y 2
      z 3]
  (+ x y z))
;; => 6
----

This is practically all the syntax we need to know for using not only ClojureScript, but any Lisp. Being
written in its own data structures (often referred to as _homoiconicity_) is a great property since the
syntax is uniform and simple; also, code generation via macros is easier than in any other language, giving
us plenty of power for extending the language to suit our needs.

=== The base data types

The ClojureScript language has a rich set of data types like most programming languages. It provides
scalar datatypes that will be very familiar to you, such as numbers, strings, and floats. Beyond these, it also
provides a great number of others that might be less familiar, such as symbols, keywords, regex (regular expressions),
vars, atoms, volatiles...

_ClojureScript_ embraces the host language, and where possible it uses the host's provided types. For example:
numbers and strings are used as is and they behave in same way as in JavaScript.


==== Numbers

In _ClojureScript_,  numbers include both integers and floating points. Keeping in mind that
_ClojureScript_ is a guest language that compiles to JavaScript, integers are actually JavaScript's native
floating points under the hood.

As in any other language, numbers in _ClojureScript_ are represented in following way:

[source, clojure]
----
23
+23
-100
1.7
-2
33e8
12e-14
3.2e-4
----


==== Keywords

Keywords in _ClojureScript_ are objects that always evaluate to themselves. They are usually
used in map data structures to efficiently represent the keys.

[source, clojure]
----
:foobar
:2
:?
:foo/bar
----

As you can see, the keywords are all prefixed with `:`, but this character is only part
of the literal syntax and is not part of the name of the object.

You can also create a keyword by calling the `keyword` function. Don't worry if you don't understand
or are unclear about anything in the following example; the functions are discussed in later chapters.

[source, clojure]
----
(keyword "foo")
;; => :foo
----


==== Symbols

Symbols in _ClojureScript_ are very, very similar to *Keywords* (which you now know about). But
instead of evaluating to themselves, symbols are evaluated to something that they refer to, that
can be functions, variables, etc.

Symbols are represented with something that does not start with a number:

[source, clojure]
----
sample-symbol
othersymbol
f1
----

Don't worry if you don't understand right away; symbols are used in almost
all of our examples, which will give you the opportunity to learn more as we go on.


==== Strings

There is almost nothing new we can explain about strings that you don't already know. In _ClojureScript_, they
 work the same as in any other language. One point of interest, however, is that they are immutable.

In this case they are the same as in JavaScript:

[source, clojure]
----
"A example of a string"
----

One peculiar aspect of Strings in _ClojureScript_ is due to the language's Lisp syntax: single and multiline strings
have the same syntax:

[source, clojure]
----
"This is a multiline
      string in ClojureScript."
----

==== Characters

_ClojureScript_ also lets you write single characters using Clojure's character literal syntax.

[source, clojure]
----
\a        ; The lowercase a character
\newline  ; The new line character
----

Since the host language doesn't contain character literals, _ClojureScript_ characters are transformed
behind the scenes into single character JavaScript strings.


==== Collections

Another big step in explaining a language is to explain its collections and collection
abstractions. _ClojureScript_ is not an exception to this rule.

_ClojureScript_ comes with many types of different collections. The main difference between _ClojureScript_
collections and collections in other languages is that they are persistent and immutable.

Before moving on to all of these (possibly) unknown concepts, we'll present a high level overview
of existing collection types in _ClojureScript_.


===== Lists

This is a classic collection type in languages based on Lisp. Lists are the
simplest type of collection in _ClojureScript_. Lists can contain items of any type, including
other collections.

Lists in _ClojureScript_ are represented by items enclosed between parentheses:

[source, clojure]
----
'(1 2 3 4 5)
'(:foo :bar 2)
----

As you can see, all list examples are prefixed with the `'` char. This is because lists in Lisp like
languages are often used to express things like function or macro calls. In that case
the first item should be a symbol that will evaluate to a something callable, and the rest of the list
elements will be function parameters. However, in the preceding examples, we don't want the first item as a symbol;
we just want a list of items.  The following example shows the difference between a list without and with the preceding
single quote mark:

[source, clojure]
----
(inc 1)
;; => 2

'(inc 1)
;; => (inc 1)
----

As you see, if you  evaluate `(inc 1)` without prefixing it with `'`, it will resolve
the `inc` symbol to the *inc* function and will execute it with `1` as first parameter returning the value `2`.

You can also explicitly create a list with the `list` function:

[source, clojure]
----
(list 1 2 3 4 5)
;; => (1 2 3 4 5)

(list :foo :bar 2)
;; => (:foo :bar 2)
----

Lists have the pecularity that they are very efficient if you access them sequentially or
access their first elements, but a list is not a very good option if you need random (index) access to it's
elements.


===== Vectors

Like lists, *Vectors*  store a series of values, but in this case with very efficient index access
to their elements, as opposed to lists, which are evaluated in order. Don't worry; in
the following chapters we'll go in depth with details, but at this moment, this simple explanation is
more than enough.

Vectors use square brackets for the literal syntax; let's see some examples:

[source, clojure]
----
[:foo :bar]
[3 4 5 nil]
----

Like lists, vectors can contain objects of any type, as you can observe in the preceding example.

You can also explicitly create a vector with the `vector` function, but this is not commonly used in ClojureScript programs:

[source, clojure]
----
(vector 1 2 3)
;; => [1 2 3]

(vector "blah" 3.5 nil)
;; => ["blah" 3.5 nil]
----


===== Maps

Maps are a collection abstraction that allows you to store key/value pairs. In other
languages this type of structure is commonly known as a hash-map or dicts (dictionaries). Map literals
in _ClojureScript_ are written with the pairs between curly braces.

[source, clojure]
----
{:foo "bar", :baz 2}
{:alphabet [:a :b :c]}
----

NOTE: Commas are frequently used to separate a key-value pair but are completely optional. In
_ClojureScript_ syntax, commas are treated like spaces.

Like Vectors, every item in a map literal is evaluated before the result is stored in a map, but
the order of evaluation is not guaranteed.


===== Sets

And finally, *Sets*.

Sets store zero or more unique items of any type and are unordered. They,
like maps, use curly braces for their literal syntax, with the difference being that they use a `#` as leading
character:

[source, clojure]
----
#{1 2 3 :foo :bar}
----

In subsequent chapters we'll go in depth about sets and the other collection types you've seen in this
chapter.


=== Vars

_ClojureScript_ is a mostly functional language and focused on immutability. Because of that, it does
not have the concept of variables as you know them in most other programming languages. The closest analogy to
variables are the variables you define in algebra; when you say `x = 6` in mathematics, you are saying that you
want the symbol `x` to stand for the number six.

In _ClojureScript_, vars are represented by symbols and store a single value together with metadata.

You can define a var using a `def` special form:

[source, clojure]
----
(def x 22)
(def y [1 2 3])
----

Vars are always top level in the namespace (which we will explain later). If you use `def` in a function call,
the var will be defined at the namespace level, but we do not recommend this - instead, you should use `let`
to define variables within a function.


=== Functions

==== The first contact

It's time to make things happen. _ClojureScript_, has what are known as first class functions. They behave
like any other type, you can pass them as parameters and you can return them as values, always respecting
the lexical scope. _ClojureScript_ also has some features of dynamic scoping, but this will be discussed
in other section.

If you want know more about scopes, this link:http://en.wikipedia.org/wiki/Scope_(computer_science)[wikipedia article]
is very extensive and explains different types of scoping.

As _ClojureScript_ is a Lisp dialect, it uses the prefix notation for calling a function:

[source, clojure]
----
(inc 1)
;; => 2
----

In the example above, `inc` is a function and is part of the _ClojureScript_ runtime, and `1` is the first
argument for the `inc` function.

[source, clojure]
----
(+ 1 2 3)
;; => 6
----

The `+` symbol represents an `add` function. It allows multiple parameters, whereas in ALGOL-type languages,
`+` is an operator and only allows two parameters.

The prefix notation has huge advantages, some of them not always obvious. _ClojureScript_ does not
make a distinction between a function and operator; everything is a function. The immediate advantage
is that the prefix notation allows an arbitrary number of arguments per "operator". Also, it completely
eliminates the problem of operator precedence.


==== Defining your own functions

You can define an un-named (anonymous) function with the `fn` special form. This is one type of function definition;
in the following example, the function takes two parameters and returns their average.

[source, clojure]
----
(fn [param1 param2]
  (/ (+ param1 param2) 2.0)
----

You can define a function and call it at same time (in a single expression):

[source, clojure]
----
((fn [x] (* x x)) 5)
;; => 25
----

Let's start creating named functions. But what does a _named function_ really mean? It is very simple;
as in _ClojureScript_, functions are first-class and behave like any other value, so naming a function
is done by simply binding the function to a symbol:

[source, clojure]
----
(def square (fn [x] (* x x)))

(square 12)
;; => 144
----

_ClojureScript_ also offers the `defn` macro as a little syntactic sugar for making function definition
more idiomatic:

[source, clojure]
----
(defn square
  "Return the square of a given number."
  [x]
  (* x x))
----

The string that comes between the function name and the parameter vector is called a
_docstring_ (documentation string); programs that automatically create web documentation
from your source files will use these docstrings.


==== Function with multiple arities

_ClojureScript_ also comes with the ability to define functions with arbitrary number of
arguments. (The term _arity_ means the number of arguments that a function takes.) The
syntax is almost the same as for defining an ordinary function, with the difference that
it has more than one body.

Let's see an example, which will surely explain it much better:

[source, clojure]
----
(defn myinc
  "Self defined version of parameterized `inc`."
  ([x] (myinc x 1))
  ([x increment]
   (+ x increment)))
----

This line: `([x] (myinc x 1)` says that if there is only one argument, call the function
`myinc` with that argument and the number `1` as the second argument. The other function body:
`([x increment] (+ x increment))` says that if there are two arguments, return the result of
adding them.

Here are some examples using the previously defined multi-arity function. Observe that
if you call a function with wrong number of arguments, the compiler will emit an error message.

[source, clojure]
----
(myinc 1)
;; => 1

(myinc 1 3)
;; => 4

(myinc 1 3 3)
;; Compiler error
----

[NOTE]
Explaining the concept of "arity" is out of the scope of this book, however you can read about that in this
link:http://en.wikipedia.org/wiki/Arity[wikipedia article].


==== Variadic functions

Another way to accept multiple parameters is defining variadic functions. Variadic functions
are functions that will be able to accept an arbitrary number of arguments:

[source, clojure]
----
(defn my-variadic-set
  [& params]
  (set params))

(my-variadic-set 1 2 3 1)
;; => #{1 2 3}
----

The way to denote a variadic function is using the `&` symbol prefix on its arguments vector.


==== Short syntax for anonymous functions

_ClojureScript_ provides a shorter syntax for defining anonymous functions using
the `#()` reader macro (usually leads to one liners). Reader macros are "special" expressions that will be
transformed to the appropriate language form at compile time; in this case, to some expression
that uses `fn` special form.

[source, clojure]
----
(def my-set #(set (list %1 %2)))

(my-set 1 2)
;; => #{1 2}
----

The preceding definition is shorthand for:

[source,clojure]
----
(def my-set-longer (fn [a b] #(set (list a b))))
----

The `%1`, `%2`, `%N` are simple markers for parameter positions that are implicitly declared when
the reader macro will be interpreted and converted to a `fn` expression.

Also, if a function only accepts one argument, you can omit the number after `%` symbol; the
function `#(set (list %1))` can be written `++#++(set (list %))`.

Additionally, this syntax also supports the variadic form with the`%&` symbol:

[source, clojure]
----
(def my-variadic-set #(set %&))

(my-variadic-set 1 2 2)
;; => #{1 2}
----


=== Flow control

_ClojureScript_ has a very different approach for flow control than languages like JavaScript, C, etc.


==== Branching with `if`

Let start with a basic one: `if`. In _ClojureScript_ the `if` is an expression and not a
statement, and it has three parameter: the first one is the condition expression, the second one
is an expression that will be evaluated if the condition expression evaluates to logical true,
and the third expression will be evaluated otherwise.

[source, clojure]
----
(defn discount
  "You get 5% discount for ordering 100 or more items"
  [quantity]
  (if (>= quantity 100)
    0.05
    0))

(discount 30)
;; => 0

(discount 130)
;; => 0.05
----

The block expression `do` can be used to have multiple expressions in an `if` branch.
`do` is explained in the next section.


==== Branching with `cond`

Sometimes, the `if` expression can be slightly limited because it does not have the "else if" part
to add more than one condition. The `cond` comes to the rescue.

With the `cond` expression, you can define multiple conditions:

[source, clojure]
----
(defn mypos?
  [x]
  (cond
    (> x 0) "positive"
    (< x 0) "negative"
    :else "zero"))

(mypos? 0)
;; => "zero"

(mypos? -2)
;; => "negative"
----

Also, `cond` has another form, called `condp`, that works very similarly to the simple `cond`
but looks cleaner when the condition (also called a predicate) is the same for all conditions:

[source, clojure]
----
(defn translate-lang-code
  [code]
  (condp = (keyword code)
    :es "Spanish"
    :en "English"
    "Unknown"))

(translate-lang-code "en")
;; => "English"

(translate-lang-code "fr")
;; => "Unknown"
----

The line `condp = (keyword code)` means that, in each of the following lines, _ClojureScript_
will apply the `=` function to the given keyword and the `code` argument.


==== Branching with `case`

The `case` branching expression has very similar use case as our previous example with
`condp`. The main difference is that `case` always uses the `=` predicate/function, and its
branching values are evaluated at compile time. This results in a more performant form
than `cond` or `condp` but has the disadvantage that the condition value must be
a static value.

Here is the same example as previous one, but using `case`:

[source, clojure]
----
(defn translate-lang-code
  [code]
  (case code
    "es" "Spanish"
    "es" "English"
    "Unknown"))

(translate-lang-code "en")
;; => "English"

(translate-lang-code "fr")
;; => "Unknown"
----


=== Locals, Blocks and Loops

==== Locals

_ClojureScript_ does not has the concept of variables as in ALGOL-like languages, but it does
have locals. Locals, as per usual, are immutable, and if you try mutate them, the compiler
will throw an error.

The locals are defined with the `let` expression. The expression starts with a vector as first parameter
followed by arbitrary number of expressions. The first parameter (the vector) should contain an arbitrary
number of pairs that give a _binding form_ (usually a symbol) followed by an expression whose value will
be bound to this new local for the remainder of the let expression.

[source, clojure]
----
(let [x (inc 1)
      y (+ x 1)]
  (println "Simple message from the body of a let")
  (* x y))
;; Simple message from the body of a let
;; => 6
----

In the preceding example, the symbol `x` is bound to the value `(inc 1)`, which comes out to 2,
and the symbol `y` is bound to the sum of `x` and 1, which comes out to 3. Given those bindings, the
expressions `(println "Simple message from the body of a let")` and `(* x y)` are evaluated.


==== Blocks

In JavaScript, braces `{` and `}` delimit a block of code that “belongs together.” Blocks in
_ClojureScript_ are created using the `do` expression and are usually used for side effects, like
printing something to the console or writing a log in a logger.

A side effect is something that is not necessary for the return value.

The `do` expression accepts as its parameter an arbitrary number of other expressions, but it returns
the return value only from the last one:

[source, clojure]
----
(do
   (println "hello world")
   (println "hola mundo")
   (* 3 5) ;; this value will not be returned; it is thrown away
   (+ 1 2))

;; hello world
;; hola mundo
;; => 3
----

The body of the `let` expression, explained in previous section, is very similar to the
`do` expression, in that it allows multiple expressions. In fact, the `let` has an implicit `do`.


==== Loops

The functional approach of _ClojureScript_ means that it does not have standard,
well known statement-based loops such as `for` in JavaScript. The loops in _ClojureScript_ are handled using recursion.
Recursion sometimes requires additional thinking about how to model your problem in
a slightly different way than imperative languages.

Also, many of the common patterns for which `for` is used in other languages are achieved
through higher-order functions - functions that accept other functions as parameters.


===== Looping with loop/recur

Let's take a look at how to express loops using recursion with the `loop` and `recur` forms.
`loop` defines a possibly empty list of bindings (notice the symmetry with `let`) and `recur`
jumps execution back to the looping point with new values for those bindings.

Let's see an example:

[source, clojure]
----
(loop [x 0]
   (println "Looping with " x)
   (if (= x 2)
     (println "Done looping!")
     (recur (inc x))))
;; Looping with 0
;; Looping with 1
;; Looping with 2
;; Done looping!
;; => nil
----

In the above snippet, we bind the name `x` to the value `0` and execute the body. Since the
condition is not met the first time it's run we `recur`, incrementing the binding value with
the `inc` function. We do this once more until the condition is met and, since there aren't
more `recur` calls, exit the loop.

Note that `loop` isn't the only point we can `recur` to; using `recur` inside a function
executes the body of the function recursively with the new bindings:

[source, clojure]
----
(defn recursive-function [x]
   (println "Looping with" x)
   (if (= x 2)
     (println "Done looping!")
     (recur (inc x))))

(recursive-function 0)
;; Looping with 0
;; Looping with 1
;; Looping with 2
;; Done looping!
;; => nil
----


===== Replacing for loops with higher-order functions

In imperative programming languages it is common to use `for` loops to iterate over data and
transform it, usually the intent being one of the following:

- Transform every value in the iterable yielding another iterable
- Filter the elements of the iterable by certain criteria
- Convert the iterable to a value where each iteration depends on the result from the previous one
- Run a computation for every value in the iterable

The above actions are encoded in higher-order functions and syntactic constructs in ClojureScript;
let's see an example of the first three.

For transforming every value in an iterable data structure we use the `map` function, which takes a
function and a sequence and applies the function to every element:

[source, clojure]
----
(map inc [0 1 2])
;; => (1 2 3)
----

For filtering the values of a data structure we use the `filter` function, which takes a predicate
and a sequence and gives a new sequence with only the elements that returned `true` for the given
predicate:

[source, clojure]
----
(filter odd? [1 2 3 4])
;; => (1 3)
----

Converting an iterable to a single value, accumulating the intermediate result at every step of the iteration
can be achieved with `reduce`, which takes a function for accumulating values, an optional initial value
and a collection:

[source, clojure]
----
(reduce + 0 [1 2 3 4])
;; => 10
----


===== `for` sequence comprehensions

In ClojureScript the `for` construct isn't used for iteration but for generating sequences, an operation
also known as "sequence comprehension". It offers a small domain specific language for declaratively
building sequences.

`for` takes a vector of bindings and a expression and generates a sequence of the result of evaluating the
expression. Let's take a look at an example:

[source, clojure]
----
(for [x [1 2 3]]
  [x x])
;; => ([1 1] [2 2] [3 3])
----

In this example, `x` is bound to each of the items in the vector `[1 2 3]` in turn, and returns a new
sequence of two-item vectors with the original item repeated.

`for` supports multiple bindings, which will cause the collections to be iterated in a nested fashion, much
like nesting `for` loops in imperative languages. The innermost binding iterates “fastest.”

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]]
  [x y])

;; => ([1 4] [1 5] [2 4] [2 5] [3 4] [3 5])
----

We can also follow the bindings with three modifiers: `:let` for creating local bindings, `:while` for
breaking out of the sequence generation, and `:when` for filtering out values.

Here's an example of local bindings using the `:let` modifier; note that the bindings defined with it
will be available in the expression:

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]]
  z)
;; => (5 6 6 7 7 8)
----

We can use the `:while` modifier for expressing a condition that, when it is no longer met, will stop
the sequence generation. Here's an example:

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :while (= y 4)]
  [x y])

;; => ([1 4] [2 4] [3 4])
----

For filtering out generated values, use the `:when` modifier as in the following example:

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :when (= (+ x y) 6)]
  [x y])

;; => ([1 5] [2 4])
----

We can combine the modifiers shown above for expressing complex sequence generations or
more clearly expressing the intent of our comprehension:

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]
      :when (= z 6)]
  [x y])

;; => ([1 5] [2 4])
----

When we outlined the most common usages of the `for` construct in imperative programming languages,
we mentioned that sometimes we want to run a computation for every value in a sequence, not caring
about the result. Presumably we do this for achieving some sort of side-effect with the values of
the sequence.

ClojureScript provides the `doseq` construct, which is analogous to `for` but executes the expression,
discards the resulting values, and returns `nil`.

[source, clojure]
----
(doseq [x [1 2 3]
        y [4 5]
       :let [z (+ x y)]]
  (println x "+" y "=" z))

;; 1 + 4 = 5
;; 1 + 5 = 6
;; 2 + 4 = 6
;; 2 + 5 = 7
;; 3 + 4 = 7
;; 3 + 5 = 8
;; => nil
----


=== Collection types


==== Immutable and persistent

We mentioned before that ClojureScript collections are persistent and immutable, but we didn't explain what
that meant.

An immutable data structure, as its name suggest, is a data structure that can not be changed. In-place
updates are not allowed in immutable data structures.

A persistent data structure is a data structure that returns a new version of itself when transforming
it, leaving the original unmodified. ClojureScript makes this memory and time efficient using an
implementation technique called _structural sharing_, where most of the data shared between two versions
of a value is not duplicated, and transformations of a value are implemented by copying the minimal amount of data
required.

Let's see an example of appending values to a vector using the `conj` (for "conjoin") operation:

[source, clojure]
----
(let [xs [1 2 3]
      ys (conj xs 4)]
  (println "xs:" xs)
  (println "ys:" ys))

;; xs: [1 2 3]
;; ys: [1 2 3 4]
;; => nil
----

As you can see, we derived a new version of the `xs` vector appending an element to it and got a new
vector `ys` with the element added. However, the `xs` vector remained unchanged, because it is immutable.

For illustrating the structural sharing of ClojureScript data structures, let's compare whether some parts
of the old and new versions of a data structure are actually the same object with the `identical?` predicate.
We'll use the list data type for this purpose:

[source, clojure]
----
(let [xs (list 1 2 3)
      ys (cons 0 xs)]
  (println "xs:" xs)
  (println "ys:" ys)
  (println "(rest ys):" (rest ys))
  (identical? xs (rest ys)))

;; xs: (1 2 3)
;; ys: (0 1 2 3)
;; (rest ys): (1 2 3)
;; => true
----

As you can see in the example, we used `cons` (construct) to prepend a value to the `xs` list and we got
a new list `ys` with the element added. The `rest` of the `ys` list (all the values but the first)
are the same object in memory as the `xs` list, thus `xs` and `ys` share structure.


==== The sequence abstraction

One of the central ClojureScript abstractions is the Sequence, which can be thought of as a list and can be derived
from any of the collection types. It is persistent and immutable like all collection types, and many of the
core ClojureScript functions return sequences.

The types that can be used to generate a sequence are called "seqables"; we can call `seq` on them and get
a sequence back. Sequences support two basic operations: `first` and `rest`. They both call `seq` on the
argument we provide them:

[source, clojure]
----
(first [1 2 3])
;; => 1

(rest [1 2 3])
;; => (2 3)
----

Calling `seq` on a seqable can yield different results if the seqable is empty or not. It will return `nil`
when empty and a sequence otherwise:

[source, clojure]
----
(seq [])
;; => nil

(seq [1 2 3])
;; => (1 2 3)
----

`next` is a similar sequence operation to `rest`, but it differs from the latter in that it yields a `nil` value
when called with a sequence with one or zero elements. Note that, when given one of the aforementioned sequences,
the empty sequence returned by `rest` will evaluate as a boolean true whereas the `nil` value returned by `next`
will evaluate as false (see the section on _truthiness_ later in this chapter).

[source, clojure]
----
(rest [])
;; => ()

(next [])
;; => nil

(rest [1 2 3])
;; => (2 3)

(next [1 2 3])
;; => (2 3)
----

////
This seems like a very advanced concept for the first chapter.
TODO: think about this.
////

===== nil-punning

The above behaviour of `seq` when coupled with the falsey nature of `nil` in boolean contexts make it an idiom for checking
the emptyness of a sequence in ClojureScript, which is often referred to as nil-punning.

[source, clojure]
----
(defn print-coll
  [coll]
  (when (seq coll)
    (println "Saw " (first coll))
    (recur (rest coll))))

(print-coll [1 2 3])
;; Saw 1
;; Saw 2
;; Saw 3
;; => nil

(print-coll #{1 2 3})
;; Saw 1
;; Saw 3
;; Saw 2
;; => nil
----

`nil` is also both a seqable and a sequence, and thus it supports all the functions we saw so far:

[source, clojure]
----
(seq nil)
;; => nil

(first nil)
;; => nil

(rest nil)
;; => ()
----


===== Functions that work on sequences

The ClojureScript core functions that work on collections call `seq` on their arguments, thus being
implemented in terms of generic sequence operations. This also makes them short-circuit when encountering empty
collections and makes them `nil`-safe.

////
The last sentence in the preceding paragraph really needs an example. I think it is far too complicated
for a book that assumes "no previous experience with Clojure or functional programming."
TODO:
////

We already saw examples with the usual suspects like `map`, `filter` and `reduce`, but ClojureScript offers a
plethora of generic sequence operations in its core namespace. Note that many of the operations we'll learn about
either work with seqables or are extensible to user defined types.

We can query a value to know whether it's a collection type with the `coll?` predicate:
[source, clojure]
----
(coll? nil)
;; => false

(coll? [1 2 3])
;; => true

(coll? {:language "ClojureScript" :file-extension "cljs"})
;; => true

(coll? "ClojureScript")
;; => false
----

Similar predicates exist for checking if a value is sequence (`seq?`) or a seqable (`seqable?`):
[source, clojure]
----
(seq? nil)
;; => false
(seqable? nil)
;; => false

(seq? [])
;; => false
(seqable? [])
;; => true

(seq? #{1 2 3})
;; => false
(seqable? #{1 2 3})
;; => true

(seq? "ClojureScript")
;; => false
(seqable? "ClojureScript")
;; => false
----

For collections that can be counted in constant time, we can use the `count` operation:

[source, clojure]
----
(count nil)
;; => 0

(count [1 2 3])
;; => 3

(count {:language "ClojureScript" :file-extension "cljs"})
;; => 2

(count "ClojureScript")
;; => 13
----

We can also get an empty variant of a given collection with the `empty` function:

[source, clojure]
----
(empty nil)
;; => nil

(empty [1 2 3])
;; => []

(empty #{1 2 3})
;; => #{}
----

The `empty?` predicate returns true if the given collection is empty:

[source, clojure]
----
(empty? nil)
;; => true

(empty? [])
;; => true

(empty? #{1 2 3})
;; => false
----

The `conj` operation adds elements to collections and may add them in different "places" depending
on the collection. It adds them where it is most performant for the collection type,
but note that not every collection has a defined order.

We can pass as many elements we want to add to `conj`; let's see it in action:

[source, clojure]
----
(conj nil 42)
;; => (42)

(conj [1 2] 3)
;; => [1 2 3]

(conj [1 2] 3 4 5)
;; => [1 2 3 4 5]

(conj '(1 2) 0)
;; => (0 1 2)

(conj #{1 2 3} 4)
;; => #{1 3 2 4}

(conj {:language "ClojureScript"} [:file-extension "cljs"])
;; => {:language "ClojureScript", :file-extension "cljs"}
----


===== Laziness

Most of ClojureScript's sequence-returning functions generate lazy sequences instead of eagerly creating
a whole new sequence. Lazy sequences generate their contents as they are requested, usually when iterating
over them. Laziness ensures that we don't do more work than we need to and gives us the possibility of
treating potentially infinite sequences as regular ones.

TODO

==== Collections in depth

Now that we're acquainted with ClojureScript's sequence abstraction and some of the generic sequence manipulating
functions, it's time to dive into the concrete collection types and the operations they support.


===== Lists

In ClojureScript lists are mostly used as a data structure for grouping symbols together into programs. Unlike in other
Lisps, many of the syntactic constructs of ClojureScript use data structures different from the list (vectors and maps).
This makes code less uniform, but the gains in readability are well worth the price.

You can think of ClojureScript lists as singly linked lists, where each node contains a value and a pointer to the rest of the list.
This makes natural (and fast!) to add items to the front of the list since adding to the end would require traversal of the entire
list. The prepend operation is performed using the `cons` (construct) function.

[source, clojure]
----
(cons 0 (cons 1 (cons 2 ())))
;; => (0 1 2)
----

We used the literal `()` to represent the empty list. Since it doesn't contain any symbols, it is not treated
as a function call. However, when using list literals that contain elements, we need to quote them to
prevent ClojureScript from evaluating them as a function call:

[source, clojure]
----
(cons 0 '(1 2))
;; => (0 1 2)
----

Since the head is the position that has constant time addition in the list collection, the `conj` operation
on lists naturally adds item in the front:

[source, clojure]
----
(conj '(1 2) 0)
;; => (0 1 2)
----

Lists and other ClojureScript data structures can be used as stacks using the `peek`, `pop`, and `conj` functions.
Note that the top of the stack will be the "place" where `conj` adds elements to, making `conj` equivalent to the
stack's push operation. In the case of lists, `conj` adds elements to the front of the list, `peek` returns the first
element of the list, and `pop` returns a list with all the elements but the first one.

Note that the two operations that return a stack (`conj` and `pop`) don't change the type of the collection used for
the stack.

[source, clojure]
----
(def list-stack '(0 1 2))

(peek list-stack)
;; => 0

(pop list-stack)
;; => (1 2)

(type (pop list-stack))
;; => cljs.core/List

(conj list-stack -1)
;; => (-1 0 1 2)

(type (conj list-stack -1))
;; => cljs.core/List
----

One thing that lists are not particularly good at is random indexed access. Since they are stored in a single linked list-like
structure in memory, random access to a given index requires a linear traversal in order to either retrieve the requested
item or throw an index out of bounds error. Non-indexed ordered collections like lazy sequences also suffer from this limitation.


===== Vectors

Vectors are one of the most common data structures in ClojureScript. They are used as a syntactic construct in many
places where more traditional Lisps use lists, for example in function argument declarations and `let` bindings.

ClojureScript vectors have enclosing brackets `[]` in their syntax literals. They can be created with `vector` and from
another collection with `vec`:

[source,clojure]
----
(vector? [0 1 2])
;; => true

(vector 0 1 2)
;; => [0 1 2]

(vec '(0 1 2))
;; => [0 1 2]
----

Vectors are, like lists, ordered collections of heterogeneous values. Unlike lists, vectors grow naturally from the tail,
so the `conj` operation appends items to the end of a vector. Insertion on the end of a vector is effectively constant
time:

[source,clojure]
----
(conj [0 1] 2)
;; => [0 1 2]
----

Another thing that differentiates lists and vectors is that vectors are indexed collections and as such support efficient
random index access and non-destructive updates. We can use the familiar `nth` function to retrieve values given an index:

[source, clojure]
----
(nth [0 1 2] 0)
;; => 0
----

Since vectors associate sequential numeric keys (indexes) to values, we can treat them as an associative data structure. ClojureScript
provides the `assoc` function that, given an associative data structure and a set of key-value pairs, yields a new data structure with
the values corresponding to the keys modified. Indexes begin at zero for the first element in a vector.

[source, clojure]
----
(assoc ["cero" "uno" "two"] 2 "dos")
;; => ["cero" "uno" "dos"]
----

Note that we can only `assoc` to a key that is either contained in the vector already or if it's the last position in a vector:

[source, clojure]
----
(assoc ["cero" "uno" "dos"] 3 "tres")
;; => ["cero" "uno" "dos" "tres"]

(assoc ["cero" "uno" "dos"] 4 "cuatro")
;; Error: Index 4 out of bounds [0,3]
----

Perhaps surprisingly, associative data structures can also be used as functions. They are functions of their keys to the values they
are associated with. In the case of vectors, if the given key is not present an exception is thrown:

[source, clojure]
----
(["cero" "uno" "dos"] 0)
;; => "cero"

(["cero" "uno" "dos"] 2)
;; => "dos"

(["cero" "uno" "dos"] 3)
;; Error: Not item 3 in vector of length 3
----

As with lists, vectors can be also used as stack with the `peek`, `pop` and `conj` functions. Note, however, that vectors grow
from the opposite end of the collection as lists:

[source, clojure]
----
(def vector-stack [0 1 2])

(peek vector-stack)
;; => 2

(pop vector-stack)
;; => [0 1]

(type (pop vector-stack))
;; => cljs.core/PersistentVector

(conj vector-stack 3)
;; => [0 1 2 3]

(type (conj vector-stack 3))
;; => cljs.core/PersistentVector
----

The `map` and `filter` operations return lazy sequences, but as it is common to need a fully realized sequence after performing those operations,
vector-returning counterparts of such functions are available as `mapv` and `filterv`. They have the advantages of being faster
than building a vector from a lazy sequence and making your intent more explicit:

[source, clojure]
----
(map inc [0 1 2])
;; => (1 2 3)

(type (map inc [0 1 2]))
;; => cljs.core/LazySeq

(mapv inc [0 1 2])
;; => [1 2 3]

(type (mapv inc [0 1 2]))
;; => cljs.core/PersistentVector
----

===== Maps

Maps are ubiquitous in ClojureScript. Like vectors, they are also used as a syntactic construct for attaching metadata to
vars. Any ClojureScript data structure can be used as a key in a map, although it's common to use keywords since can also
be called as functions.

ClojureScript maps are written literally as key-value pairs enclosed in braces `{}`. Alternatively, they can be created
with the `hash-map` function:

[source,clojure]
----
(map? {:name "Cirilla"})
;; => true

(hash-map :name "Cirilla")
;; => {:name "Cirilla"}

(hash-map :name "Cirilla" :surname "Fiona")
;; => {:name "Cirilla" :surname "Fiona"}
----

Since regular maps don't have a specific order, the `conj` operation just adds one or more key-value pairs to a map. `conj`
for maps expects one or more sequences of key-value pairs as its last arguments:

[source,clojure]
----
(def ciri {:name "Cirilla"})

(conj ciri [:surname "Fiona"])
;; => {:name "Cirilla", :surname "Fiona"}

(conj ciri [:surname "Fiona"] [:occupation "Wizard"])
;; => {:name "Cirilla", :surname "Fiona", :occupation "Wizard"}
----

Maps associate keys to values and, as such, are an associative data structure. They support adding associations with `assoc` and,
unlike vectors, removing them with `dissoc`. Let's explore these functions:

[source,clojure]
----
(assoc {:name "Cirilla"} :surname "Fiona")
;; => {:name "Cirilla", :surname "Fiona"}

(dissoc {:name "Cirilla"} :name)
;; => {}
----

Maps are also functions of their keys, returning the values related to the given key. Unlike vectors, they return `nil` if we supply
a key that is not present in the map:

[source,clojure]
----
({:name "Cirilla"} :name)
;; => "Cirilla"

({:name "Cirilla"} :surname)
;; => nil
----

ClojureScript also offers sorted hash maps which behave like their unsorted versions but preserve order when iterating over them. We
can create a sorted map with default ordering with `sorted-map`:

[source,clojure]
----
(def sm (sorted-map :c 2 :b 1 :a 0))
;; => {:a 0, :b 1, :c 2}

(keys sm)
;; => (:a :b :c)
----

If we need a custom ordering we can provide a comparator function to `sorted-map-by`, let's see an example inverting the value
returned by the built-in `compare` function. Comparator functions take two elements to compare and returns -1 (less than), 0 (equal)
or 1 (greater than):

[source,clojure]
----
(def reverse-compare (comp - compare))

(def sm (sorted-map-by reverse-compare :a 0 :b 1 :c 2))
;; => {:c 2, :b 1, :a 0}

(keys sm)
;; => (:c :b :a)
----


===== Sets

Sets in ClojureScript have literal syntax as values enclosed in `#{}` and they can be created with the `set` constructor. They are
unordered collections of values without duplicates.

[source,clojure]
----
(set? #{\a \e \i \o \u})
;; => true

(set [1 1 2 3])
;; => #{1 2 3}
----

Set literals can not contain duplicate values. If you accidentaly write a set literal with duplicates an error will be thrown:

[source,clojure]
----
#{1 1 2 3}
;; clojure.lang.ExceptionInfo: Duplicate key: 1
----

There are many operations that can be performed with sets, although are located in the `clojure.set` namespace and thus need to be imported.
You'll learn the details of namespacing later, for now you only need to know that we are loading a namespace called `clojure.set` and binding
it to the `s` symbol.

[source,clojure]
----
(require '[clojure.set :as s])

(def danish-vowels #{\a \e \i \o \u \æ \ø \å})
;; => #{"a" "e" "å" "æ" "i" "o" "u" "ø"}

(def spanish-vowels #{\a \e \i \o \u})
;; => #{"a" "e" "i" "o" "u"}

(s/difference danish-vowels spanish-vowels)
;; => #{"å" "æ" "ø"}

(s/union danish-vowels spanish-vowels)
;; => #{"a" "e" "å" "æ" "i" "o" "u" "ø"}

(s/intersection danish-vowels spanish-vowels)
;; => #{"a" "e" "i" "o" "u"}
----

A nice property of immutable sets is that they can be nested, languages that have mutable sets can end up containing duplicate values but
that can't happen in ClojureScript. In fact, all ClojureScript data structures can be nested arbitrarily due to immutability.

Sets also support the generic `conj` operation, as every other collection does.

[source,clojure]
----
(def spanish-vowels #{\a \e \i \o \u})
;; => #{"a" "e" "i" "o" "u"}

(def danish-vowels (conj spanish-vowels \æ \ø \å))
;; => #{"a" "e" "i" "o" "u" "æ" "ø" "å"}

(conj #{1 2 3} 1)
;; => #{1 3 2}
----

They acts as read-only associative data that associates the values it contains to themselves. Since every value except `nil` and `false` are
falsy in ClojureScript, we can use sets as predicate functions:

[source,clojure]
----
(def vowels #{\a \e \i \o \u})
;; => #{"a" "e" "i" "o" "u"}

(get vowels \b)
;; => nil

(contains? vowels \b)
;; => false

(vowels \a)
;; => "a"

(filter vowels "Hound dog")
;; => ("o" "u" "o")
----

Sets have a sorted counterpart like maps do, created using the functions `sorted-set` and `sorted-set-by` which are analogous to map's `sorted-map` and `sorted-map-by`.

[source,clojure]
----
(def unordered-set #{[0] [1] [2]})
;; => #{[0] [2] [1]}

(seq unordered-set)
;; => ([0] [2] [1])

(def ordered-set (sorted-set [0] [1] [2]))
;; =># {[0] [1] [2]}

(seq unordered-set)
;; => ([0] [1] [2])
----



===== Queues





=== Destructuring

TBD


=== Namespaces

==== Defining a namespace

The _namespace_ is ClojureScript's fundamental unit of code modularity. Namespaces are analogous to Java packages or
Ruby and Python modules, and can be defined with the `ns` macro. Maybe if you have looked at a little bit of
ClojureScript source you have seen something like this at begining of the file:

[source, clojure]
----
(ns myapp.core
  "Some docstring for the namespace.")

(def x "hello")
----

Namespaces are dynamic, meaning you can create one at any time. The convention however, is to have one namespace
per file. Naturally, a namespace definition is usually at the beginning of the file, followed by an optional
docstring.

Previously we have explained vars and symbols. Every var that you define will be associated
with it's namespace. If you do not define a concrete namespace then the default one called "user" will be
used:

[source, clojure]
----
(def x "hello")
;; => #'user/x
----


==== Loading other namespaces

Defining a namespace and the vars in it is really easy, but it's not very useful if we can't
use them from other namespaces. For this purpose, the `ns` macro offers a simple way to load other
namespaces.

Observe the following:

[source, clojure]
----
(ns myapp.main
  (:require myapp.core
            clojure.string))

(clojure.string/upper-case myapp.core/x)
;; => "HELLO"
----

As you can observe, we are using fully qualified names (namespace + var name) for access to vars and
functions from different namespaces.

While this will let you access other namespaces, it's also repetitive and overly verbose. It will be especially
uncomfortable if the name of a  namespace is very large. To solve that, you can use the `:as` directive to
create an additional (usually shorter) alias to the namespace.
This is how it can be done:

[source, clojure]
----
(ns myapp.main
  (:require [myapp.core :as core]
            [clojure.string :as str]))

(str/upper-case core/x)
;; => "HELLO"
----

Additionaly, _ClojureScript_ offers a simple way to refer to specific vars or functions from a concrete namespace using the `:refer` directive.

The `:refer` directive has two possible arguments: the `:all` keyword or a vector of symbols that will
refer to vars in the namespace. With `:all`, we are indicating that we want to refer all public vars from the
namespace, and with vector we can specify the specific subset of vars that we want. Effectively, it is as if those vars and
functions are now part of your namespace, and you do not need to qualify them at all.

[source, clojure]
----
(ns myapp.main
  (:require [myapp.core :refer :all]
            [clojure.string :refer [upper-case]]))
(upper-case x)
;; => "HELLO"
----

And finally, you should know that everything located in the `cljs.core` namespace is automatically
loaded and you should not require it explicitly. Sometimes you may want declare vars that will clash
with some others defined in the `cljs.core` namespace. To do this, the `ns` macro offers another directive that
allows you to exclude specific symbols and prevent them from being automatically loaded.

Observe the following:

[source, clojure]
----
(ns myapp.main
  (:refer-clojure :exclude [min]))

(defn min
  [x y]
  (if (> x y)
    y
    x))
----

The `ns` macro also has other directives for loading host classes (`:import`) and macros
(`:refer-macros`), but these are explained in other sections.


=== Abstractions and Polymorphism

I'm sure that at more than one time you have found yourself in this situation: you have defined a great
abstraction (using interfaces or something similar) for your "business logic" and you have found
the need to deal with another module over which you have absolutely no control, and you probably
were thinking of creating adapters, proxies, and other approaches that imply a great amount
of additional complexity.

Some dynamic languages allow "monkey-patching"; languages where the classes are open and any
method can be defined and redefined at any time. Also, it is well known that this technique is a very
bad practice.

We can not trust languages that allow you to silently overwrite methods that you are using when you import third party libraries; you can not expect
consistent behavior when this happens.

These symptoms are commonly called the "expression problem".
see http://en.wikipedia.org/wiki/Expression_problem for more details

==== Protocols

The _ClojureScript_ primitive for defining "interfaces" is called a Protocol. A protocol consists of
a name and set of functions. All the functions have at least one argument corresponding to the
`this` in javascript or `self` in Python.

Protocols provide a type-based polymorphism, and the dispatch is always done by the
first argument (equivalent to JavaScript’s `this`, as previously mentioned).

A protocol looks like this:

[source, clojure]
----
(ns myapp.foobar)

(defprotocol IProtocolName
  "A docstring describing the protocol."
  (sample-method [this] "A doc string of the function associated with the protocol."))
----

NOTE: the "I" prefix is commonly used to designate the separation of protocols and types. In the clojure
community there many different opinions about how the "I" prefix should be used. In our opinion, it is an
acceptable solution to avoid name clashing and possible confusion.

From the user perspective, protocol functions are simply plain functions defined in the namespace
where the protocol is defined. As you can intuit, this namespacing of protocols allows us to avoid
any conflict between implemented protocols for the same type.


===== Extending existing types

One of the big strengths of protocols is the ability to extend existing and maybe third party types,
and this operation can be done in different ways. The majority of time you will tend to use
the *extend-protocol* or the *extend-type* macros.

This is an example of how the *extend-type* macro can be used:

[source, clojure]
----
(extend-type TypeA
  ProtocolA
  (function-from-protocol-a [this]
    ;; implementation here
    )

  ProtocolB
  (function-from-protocol-b-1 [this parameter1]
    ;; implementation here
    )
  (function-from-protocol-b-2 [this parameter1 parameter2]
    ;; implementation here
    ))
----

You can observe that with *extend-type* you are extending a single type with different protocols
in a single expression. In comparison, *extend-protocol* does the inverse;
given a protocol, it adds implementations for multiple types:

[source, clojure]
----
(extend-protocol ProtocolA
  TypeA
  (function-from-protocol-a [this]
    ;; implementation here
    )

  TypeB
  (function-from-protocol-a [this]
    ;; implementation here
    ))
----

There are other ways to extend a type with a protocol implementation, but they will be covered
in another section of this book.


===== Participate in ClojureScript abstractions

ClojureScript it self is built up on abstractions defined as protocols. Almost all behavior
in the _ClojureScript_ language itself can be adapted to third party libraries. Let's go to see a
real life example.

In previous sections we have explained the different kinds of built-in collections. For this example we
will use the *Set*. See this snipped of code:

[source, clojure]
----
(def mynums #{1 2})

(filter mynums [1 2 4 5 1 3 4 5])
;; => (1 2 1)
----

What happened? In this case, the _set_ type implements the _ClojureScript_ internal
`IFn` protocol that represents an abstraction for functions or anything callable. This way it can be
used like a callable predicate in filter.

Ok, but what happens if we want use a regular expression as predicate function for filtering
a collection of strings:

[source, clojure]
----
(filter #"^foo" ["haha" "foobar" "baz" "foobaz"])
;; TypeError: Cannot call undefined
----

The exception is raised because the RegExp type does not implements the `IFn` protocol
so it cannot behave like a callable, but that can be easily fixed:

[source, clojure]
----
(extend-type js/RegExp
  IFn
  (-invoke
   ([this a]
     (re-find this a))))
----

Let’s analyze this:  we are extending the `js/RegExp` type so that it implements the `invoke` function in the
`IFn` protocol. To invoke a regular expression `a` as if it were a function, call the `re-find` function with
the object of the function and the pattern.

Now, you will be able use the regex instances as predicates in filter operation:

[source, clojure]
----
(filter #"^foo" ["haha" "foobar" "baz" "foobaz"])
;; => ("foobar" "foobaz")
----


===== Introspection using Protocols

_ClojureScript_ comes with a useful function that allows runtime introspection: `satisfies?`. The
purpose of this function is to determinate at runtime if some object (instance of some type) satisfies the
concrete protocol.

So, with previous examples, if we check if a `set` instance satisfies a *IFn* protocol, it should
return `true`:

[source, clojure]
----
(satisfies? IFn #{1})
;; => true
----

==== Multimethods

We have previously talked about protocols, which solve a very common use case of polymorphism:
dispatch by type. But in some circumstances, the protocol approach it can be limiting. And
here, *multimethods* come to the rescue.

These *multimethods* are not limited to type dispatch only; instead, they also offer dispatch
by types of multiple arguments and by value. They also allow ad-hoc hierarchies to be defined. Also,
like protocols, multimethods are an "Open System," so you or any third parties can extend a multimethod for
new types.

The basic constructions of *multimethods* are the `defmulti` and `defmethod` forms. The
`defmulti` form is used to create the multimethod with an initial dispatch function. This is
a model of what it looks like:

[source, clojure]
----
(defmulti say-hello
  "A polymorphic function that return a greetings message
  depending on the language key with default lang as `:en`"
  (fn [param] (:locale param))
  :default :en)
----

The anonymous function defined within the `defmulti` form is a dispatch function. It will
be called in every call to `say-hello` function and should return some kind of marker object
that will be used for dispatch. In our example it returns the contents of the `:locale` key
of the first argument.

And finally, you should add implementations. That is done with `defmethod` form:

[source, clojure]
----
(defmethod say-hello :en
  [person]
  (str "Hello " (:name person "Anonymous")))

(defmethod say-hello :es
  [person]
  (str "Hola " (:name person "Anónimo")))
----

So, if you execute that function over a hash map containing the `:locale` and optionally
the `:name` key, the multimethod will first call the dispatch function to determine the
dispatch value, then it will search for an implementation for that value. If an implementation
is found, the dispatcher will execute it. Otherwise, the dispatch will search for a default implementation
(if one is specified) and execute it.

[source, clojure]
----
(say-hello {:locale :es})
;; => "Hola Anónimo"

(say-hello {:locale :en :name "Ciri"})
;; => "Hello Ciri"

(say-hello {:locale :fr})
;; => "Hello Anonymous"
----

If the default implementation is not specified, an exception will be raised notifying you
that some value does not have a implementation for that multimethod.


==== Hierarchies

Hierarchies are _ClojureScript_’s way to let you build whatever relations that your
domain may require. The hierarchies are defined in term of relations between named objects,
such as symbols, keywords or types.

The hierarchies can be defined globally or locally, depending on your needs. Like multimethods,
hierarchies are not limited to a single namespace. You can extend a hierarchy from any namespace,
not necessarily the one in which they are defined.

The global namespace is more limited, for good reasons. Keywords or symbols that are not namespaced can
not be used in the global hierarchy. That behavior helps prevent unexpected situations when
two or more third party libraries use the same symbol for different semantics.


===== Defining a hierarchy

The hierarchy relations should be established using the `derive` function:

[source, clojure]
----
(derive ::circle ::shape)
(derive ::box ::shape)
----

We have just defined a set of relationships between namespaced keywords. In this case the
`::circle` is a child of `::shape`, and `::box` is also a child of `::shape`.

TIP: The `::circle` keyword syntax is a shorthand for `:current.ns/circle`. So if you are executing
it in a REPL, `::circle` will be evaluated as `:cljs.user/circle`.


===== Hierarchies and introspection

_ClojureScript_ comes with a little toolset of functions that allow runtime introspection
of globally or locally defined hierarchies. This toolset consists of three functions:
`isa?`, `ancestors`, and `descendants`.

Let's see an example of how it can be used with the hierarchy defined in previous example:

[source, clojure]
----
(ancestors ::box)
;; => #{:cljs.user/shape}

(descendants ::shape)
;; => #{:cljs.user/circle :cljs.user/box}

(isa? ::box ::shape)
;; => true

(isa? ::rect ::shape)
;; => false
----


===== Locally defined hierarchies

As we mentioned previously, in _ClojureScript_ you also can define local hierarchies. This can be
done with the `make-hierarchy` function. Here is an example of how you can replicate the previous
example using a local hierarchy:

////
Have you explained the -> operator?
TODO: add chapter for explain the threading macros
////

[source, clojure]
----
(def h (-> (make-hierarchy)
           (derive :box :shape)
           (derive :circle :shape)))
----

Now you can use the same introspection functions with that locally defined hierarchy:

[source, clojure]
----
(isa? h :box :shape)
;; => true

(isa? :box :shape)
;; => false
----

As you can observe, in local hierarchies we can use normal (not namespace qualified) keywords,
and if we execute the `isa?` without passing the local hierarchy parameter, it returns `false`
as expected.


===== Hierarchies in multimethods

One of the big advantages of hierarchies is that they works very well together with multimethods.
This is because multimethods by default use the `isa?` function for the last step of dispatching.

Let's see an example to clearly understand what that means. Firstly, define the multimethod with
`defmulti` form:

[source, clojure]
----
(defmulti stringify-shape
  "A function that prints a human readable representation
  of a shape keyword."
  identity
  :hierarchy h)
----

With `:hierarchy` keyword parameter we indicate to the multimethod that hierarchy we want to use;
if it is not specified, the global hierarchy will be used.

Secondly, we define an implementation for our multimethod using the `defmethod` form:

[source, clojure]
----
(defmethod stringify-shape :box
  [_]
  "A box shape")

(defmethod stringify-shape :shape
  [_]
  "A generic shape")

(defmethod stringify-shape :default
  [_]
  "Unexpected object")
----

Now, let's see what happens if we execute that function with a box:

[source, clojure]
----
(stringify-shape :box)
;; => "A box shape"
----

Now everything works as expected; the multimethod executes the direct matching implementation
for the given parameter. Next, let's see what happens if we execute the same function but with the `:circle`
keyword as the parameter, which does not have the direct matching dispatch value:

[source, clojure]
----
(stringify-shape :circle)
;; => "A generic shape"
----

The multimethod automatically resolves it using the provided hierarchy, and since `:circle` is
a descendant of `:shape`, the `:shape` implementation is executed.


=== Data types

Until, now, we have used maps, sets, lists and vectors to represent our data. And in most cases, this is a
really great approach. But sometimes we need to define our own types, and in this book we will
call them *datatypes*.

A datatype provides the following:

* A unique host-backed type, either named or anonymous.
* The ability to implement protocols (inline).
* Explicitly declared structure using fields or closures.
* Map like behavior (via records, see below).


==== Deftype

The most low level construction in _ClojureScript_ for creating your own types is the `deftype` macro. As a
demonstration, we will define a type called `User`:

[source, clojure]
----
(deftype User [firstname lastname])
----

Once the type has been defined, we can create an instance of our `User`. In the
following example, the `.` after `User` indicates that we are calling a constructor.

[source, clojure]
----
(def person (User. "Triss" "Merigold"))
----

And its fields can be accessed using the prefix-dot notation:

[source, clojure]
----
(.-firstname person)
;; => "Triss"
----

Types defined with `deftype` (and `defrecord`, which we will see later) creates a host-backed class-like object
associated with the current namespace. But it has some peculiarities when we intend to use or import
it from another namespace. The types in _ClojureScript_ should be imported with the `:import` directive
of the `ns` macro:

[source, clojure]
----
(ns myns.core
  (:import otherns.User))

(User. "Cirilla" "Fiona")
----

For convenience, _ClojureScript_ also defines a constructor function caled `->User` that can be imported
in the common way using the `:require` directive.

We personally do not like this type of function, and we prefer to define our own constructors, with more
idiomatic names:

[source, clojure]
----
(defn make-user
  [firstname lastname]
  (User. firstname lastname))
----

And use it in our code instead of `->User`.


==== Defrecord

The record is a slightly higher level abstraction for defining types in _ClojureScript_ and should be
preferred way to do it.

As we know, _ClojureScript_ tends to use plain data types such as maps, but in most cases we need
a named type to represent the entities of our application. Here come the records.

A record is a datatype that implements the map protocol and therefore can be used like any other map.
And since records are also proper types, they support type-based polymorphism through protocols.

In summary: with records, we have the best of both worlds, maps that can play in different
abstractions.

Let start defining the `User` type but using records:

[source, clojure]
----
(defrecord User [firstname lastname])
----

It looks really similar to the `deftype` syntax; in fact, it uses `deftype` behind the scenes as a low level
primitive for defining types.

Now, look at the difference with raw types for access to its fields:

[source, clojure]
----
(def person (User. "Yennefer" "of Vengerberg"))

(:firstname user)
;; => "Yennefer"

(get person :firstname)
;; => "Yennefer"
----

As we mentioned previously, records are maps and act like tham:

[source, clojure]
----
(map? person)
;; => true
----

And like maps, tham support extra fields that are not initially defined:

[source, clojure]
----
(def person2 (assoc person :age 92))

(:age person2)
;; => 92
----

As we can see, the `assoc` function works as expected and returns a new instance of the same
type but with new key value pair. But take care with `dissoc`! Its behavior with records is slightly
different than with maps; it will return a new record if the field being dissociated is an optional
field, but it will return a plain map if you dissociate a mandatory field.

An other difference with maps is that records do not act like functions:

[source, clojure]
----
(def plain-person {:firstname "Yennefer", :lastname "of Vengerberg"})

(plain-person :firstname)
;; => "Yennefer"

(person :firstname)
;; => person.User does not implement IFn protocol.
----

For convenience, the `defrecord` macro, like `deftype`, exposes a `->User` function, as well as an additional
`map->User` constructor function. We have the same opinion about that constructor as with
`deftype` defined ones: we recommend defining your own instead of using the other ones. But as they exist, let’s see
how they can be used:

[source, clojure]
----
(def cirilla (->User "Cirilla" "Fiona"))
(def yen (map->User {:firstname "Yennefer"
                     :lastname "of Vengerberg"}))
----


==== Implementing protocols

Both type definition primitives that we have seen so far allow inline implementations for protocols
(explained in a previous section). Let's define one for example purposes:

[source, clojure]
----
(defprotocol IUser
  "A common abstraction for working with user types."
  (full-name [_] "Get the full name of the user."))
----

Now, you can define a type with inline implementation for an abstraction, in our case the `IUser`:

[source, clojure]
----
(defrecord User [firstname lastname]
  IUser
  (full-name [_]
    (str firstname " " lastname)))

;; Create an instance.
(def user (User. "Yennefer" "of Vengerberg"))

(full-name user)
;; => "Yennefer of Vengerberg"
----


==== Reify

The `reify` macro lets you create an anonymous type that implements protocols. In contrast to
`deftype` and `defrecord`, it does not have accessible fields.

This is  how we can emulate an instance of the user type that plays well with the `IUser` abstraction:

[source, clojure]
----
(defn user
  [firstname lastname]
  (reify
    IUser
    (full-name [_]
      (str firstname " " lastname))))

(def yen (user "Yennefer" "of Vengerberg"))
(full-name user)
;; => "Yennefer of Vengerberg"
----

The real purpose of `reify` is to create an anonymous type that may implement protocols,
but you don't want the type itself.


=== Host interoperability

_ClojureScript_, in the same way as it brother Clojure, is designed to be a "Guest" language. This means
that the design of the language works well on top of an existing ecosystem such as JavaScript
for _ClojureScript_ and the JVM for _Clojure_.


==== The types.

_ClojureScript_ unlike what you might expect, tries to take advantage of every type that the platform provides. This
is a (perhaps incomplete) list of things that _ClojureScript_ inherits and reuses from the underlying
platform:

* _ClojureScript_ strings are javascript *Strings*.
* _ClojureScript_ numbers are javascript *Numbers*.
* _ClojureScript_ `nil` is a javascript *null*.
* _ClojureScript_ regular expressions are javascript `RegExp` instances.
* _ClojureScript_ is not interpreted; it is always compiled down to JavaScript.
* _ClojureScript_ allows easy call to platform APIs with the same semantics.
* _ClojureScript_ data types internally compile to objects in JavaScript.

On top of it, _ClojureScript_ builds its own abstractions and types that do not exist in the
platform, such as Vectors, Maps, Sets, and others that are explained in previous sections of this chapter.


==== Interacting with platform types

_ClojureScript_ comes with a little set of special forms that allows it interact with platform
types such as calling object methods, creating new instances, and accessing object
properties.


===== Access to the platform

_ClojureScript_ has a special syntax for access to the entire platform environment through the
`js/` special namespace. This is an example of an expression to execute JavaScript's
built-in `parseInt` function:

[source, clojure]
----
(js/parseInt "222")
;; => 222
----


===== Creating new instances

_ClojureScript_ has two ways to create instances:

.Using the `new` special form
[source, clojure]
----
(new js/RegExp "^foo$")
----

Using the `.` special form
[source, clojure]
----
(js/RegExp. "^foo$")
----

The last one is the recommended way to create instances. We are not aware of real differences
between the two forms, but in the ClojureScript community the last one is used most often.


===== Invoke instance methods

To invoke methods of some object instance, as opposed to how it is done in JavaScript (e.g.,
`obj.method()`, the method name comes first like any other standard function in Lisp languages
but with a little variation: the function name starts with special form `.`.

Let's see how we can call the `.test()` method of a regexp instance:

[source, clojure]
----
(def re (js/RegExp "^Clojure"))

(.test re "ClojureScript")
;; => true
----


===== Access to object properties

Access to the object properties is really very similar to calling a method. The difference is that
instead of using the `.` you use `.-`. Let's see an example:

[source, clojure]
----
(.-multiline re)
;; => false
(.-PI js/Math)
;; => 3.141592653589793
----


===== JavaScript objects

_ClojureScript_ has different ways to create plain JavaScript objects, each one has its own
purpose. The basic one is the `js-obj` function. It accepts a variable number of pairs of keys and
values and returns a JavaScript object:

[source, clojure]
----
(js-obj "country" "FR")
;; => #js {:country "FR"}
----

The return value can be passed to some kind of third party library that accepts a plain
JavaScript object, but you can observe the real representation of the return value of this
function. It is really another other form for doing the same thing.

Using the reader macro `#js` consists of prepending it to a ClojureScript map or vector, and the
result will be transformed to plain JavaScript:

[source, clojure]
----
(def myobj #js {:country "FR"})
----

The translation of that to plain javascript is similar to this:

[source, javascript]
----
var myobj = {country: "FR"};
----


As explained in previous section, you also can access to the plain object properties using
the `.-` syntax:

[source, clojure]
----
(.-country myobj)
;; => "FR"
----

And as JavaScript objects are mutable, you can set a new value for some property using
the `set!` function:

[source, clojure]
----
(set! (.-country myobj) "KR")
----


===== Conversions

The inconvenience of the previously explained forms is that they does not make recursive
transformations, so if you have nested objects, the nested objects will not be converted.
To solve that use cases _ClojureScript_ comes with the `clj->js` and `js->clj` functions
that transform clojure collection types into JavaScript and back:

[source, clojure]
----
(clj->js {:foo {:bar "baz"}})
;; => #js {:foo #js {:bar "baz"}}
----

In case of arrays, there is a specialized function `into-array` that behaves as expected:

[source, clojure]
----
(into-array ["France" "Korea" "Peru"])
;; => #js ["France" "Korea" "Peru"]
----


===== Arrays

In previous example we have seen how we can create an array from an existing _ClojureScript_
collection. But there is another function for creating arrays: `make-array`.

.Creating a preallocated array with length 10
[source, clojure]
----
(def a (make-array 10))
;; => #js [nil nil nil nil nil nil nil nil nil nil]
----

In _ClojureScript_ arrays also play well with sequence abstractions so you can iterate
over them or simply get the number of elements with the `count` function:

[source, clojure]
----
(count a)
;; => 10
----

As arrays on the JavaScript platform are a mutable collection type, you can access a concrete index
and set the value at that position:

[source, clojure]
----
(aset a 0 2)
;; => 2
a
;; => #js [2 nil nil nil nil nil nil nil nil nil]
----

Or access in a indexed way to get its values:

[source, clojure]
----
(aget a 0)
;; => 2
----

In JavaScript, objects are also arrays, so you can use the same functions for interacting
with plain objects:

[source, clojure]
----
(def b #js {:hour 16})
;; => #js {:hour 16}

(aget b "hour")
;; => 16

(aset b "minute" 22)
;; => 22

b
;; => #js {:hour 16, :minute 22}
----


=== State management

TBD


=== Truthiness

This is the aspect where each language has its own semantics. The majority of languages
consider empty collections, the integer 0, and other things like this to be false.
In _ClojureScript_, unlike in other languages, only two values are considered as false: `nil`
and `false`, Everything else is treated as `true`.

So, thanks to this, sets can be also be considered as predicates. If a set returns a value, it exists,
and if it returns `nil` the value does not exist:

[source, clojure]
----
(def s #{1 2})

(s 1)
;; => 1

(s 3)
;; => nil
----


=== Transducers

TBD


=== Metadata

TBD


=== A little overview of macros

TBD
