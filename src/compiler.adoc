=== Getting Started with ClojureScript compiler

At this point, surelly you are very borred with constantly teoric explication about the language
itself and want to write and execute some code. The goal of this section is make a little practical
introduction to the _ClojureScript_ compiler.

The _ClojureScript_ compiler takes the source code splited in directories and namespaces and
compiles it down to the javascript. Today, javascript has very great a mount of different environments
where it can be executed with their own pecularities.

This chapter intends to explain how to use the _ClojureScript_ without any additional tooling. This
will help you understand how the compiler works and how you can use it when other tooling are not
available (such as leiningen+cljsbuld or boot).


==== Execution environments

What is a execution environment? An execution environment is a engine, where javascript can be
executed. For example, the most popular execution environment is a Browser (Chrome, Firefox, ...)
followed by the second most popular is the nodejs/iojs.

It there others, such as Rhino (jdk6+), Nashorn (jdk8), QtQuick (QT),... but all them does not have
significant differences from the first two. So, the _ClojureScript_ at this moment may compile
the code for run in browser or in nodejs/iojs like environments out of the box.

==== Download te compiler

The _ClojureScript_ compiler is implemented in java, and for use it, you should have jdk8 installed.
_ClojureScript_ itself only requires jdk7, but the standalone compiller that we going to use in this
chapter requires jdk8.

You can download it using wget:

[source, bash]
----
wget https://github.com/clojure/clojurescript/releases/download/r3211/cljs.jar
----

The _ClojureScript_ compiler is packages in a standalone executable jar file, so this is the unique
file and jdk8 that you need for compile the _ClojureScript_ source code to javascript.



For avoid constantly have a browser for execute our compiled code, in examples of this
section we will use nodejs or iojs, so you shuld have to be installed. Nodejs is not a dependency
of _ClojureScript_, is just one of possible execution enviroments and it will used for execute our
examples.


==== Compile for nodejs/iojs

Let start with a practical example compiling code that will target to execute in *nodejs*/*iojs*. For
it you should have installed the nodejs or iojs (recommended).

It there different ways to install iojs, but the most recommended way is using the nvm (node version
manager). You can read the instructions for install and use on its
link:https://github.com/creationix/nvm[home page].

You can test the *iojs* installed in your system with this command:

[source, shell]
----
$ iojs --version
v1.7.1
----

===== Create the example application

As first step of our practical example, we should create our application directory structure
and populate it with example code.

So start creating the directory tree structure for our "hello world" application:

[source, bash]
----
mkdir -p src/myapp
touch src/myapp/core.cljs
----

Secondly, write the example code into the previously created `src/myapp/core.cljs` file:

[source, clojure]
----
(ns myapp.core
  (:require [cljs.nodejs :as nodejs]))

(nodejs/enable-util-print!)

(defn -main [& args]
  (println "Hello world!"))

(set! *main-cli-fn* -main)
----

NOTE: Is very important that the declared namespace in the file match exactly the directory
structure. Is the way how _ClojureScript_ structures its source code.


===== Compile the example application

In order to compile that source code, we need a simple build script that instructs the
_ClojureScript_ compiler the source directory and the output file. The _ClojureScript_ has a
lot of other options but at this momen we can ignore that.

Let create the _build.clj_ file with the following content:

[source, clojure]
----
(require 'cljs.closure)

(cljs.closure/build "src"
 {:output-to "main.js"
  :main myapp.core
  :target :nodejs})
----

This is a brew explanation of the used compiler options:

* The `:output-to` parameter indicates to the compiler the destination of the compiled code, in this
  case to the "main.js" file.
* The `:main` propety indicates to the compiler the namespace that will acts as the entry point of
  your application when it's executed.
* The `:target` property indicates the platform when you want execute the compiled code. In this case
  we are going to use *iojs* (formerly nodejs). If you ommit this parameter the source will be
  compiled for run in the browser environment.

For run the compilation, just execute the following command:

[source, bash]
----
java -cp cljs.jar:src clojure.main build.clj
----

And when it finishes, execute the compiled file using *iojs*:

[source, shell]
----
$ iojs main.js
"Hello world"
----


=== Working with the REPL

TBD


=== Build & Dependency management tools

==== Getting started with leiningen.

TBD

==== Getting started with boot.

TBD


=== The Closure Library

TBD


=== Browser based development

TBD

//^ A little guide and notes about implications of developing for web
//^ environments (optimizations, third party libraries, modularization, ...)

==== Using third party javascript libraryes

TBD


====  Modularizing your code

//^ Mainly related to google closure modules and slightly related to web based development
//^ Maybe this is not the chapter for this section.

TBD



=== Developing a library

//^ A little guide and implications of developing a library for clojurescript.

TBD


=== Unit testing

TBD
