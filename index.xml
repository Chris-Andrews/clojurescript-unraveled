<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc maxdepth="3"?>
<?asciidoc-numbered?>
<book lang="en">
<bookinfo>
<title>ClojureScript Unraveled</title>
<date>v1.0</date>
<author>
<firstname>Andrey Antukh &amp; Alejandro Gomez</firstname>
</author>
<authorinitials>A</authorinitials>
</bookinfo>
<chapter id="_introduction">
<title>Introduction</title>
<simpara>This chapter will be a first introduction to the clojure ecosystem, and intends to explain
the philosophy behind of it.</simpara>
<section id="_the_first_contact">
<title>The first contact.</title>
<simpara><emphasis>ClojureScript</emphasis> is a clojure language that targets javascript and can work in different
execution enviroments like browser, nodejs, iojs, nashhorn, and much others.</simpara>
<simpara>Unlike other languages that intends to <emphasis>compile</emphasis> to javascript (like typescript,
funscript or coffeescript) is designed to use the javascript like a bytecode. It embrases the
functional programming approach with very safe and consistent defaults.</simpara>
<simpara>An other big difference and in my opinion a big advantage over other languages, is that the clojure
language is designed to be guest. Is designed as language without own virtual machine that
can be easy adaptated to the host differences.</simpara>
<simpara>TBD</simpara>
</section>
<section id="_the_pillars_behind_the_language">
<title>The pillars behind the language.</title>
<simpara>TBD</simpara>
</section>
<section id="_why_the_javascript_host_improve_title">
<title>Why the javascript host (improve title).</title>
<simpara>TBD</simpara>
</section>
</chapter>
<chapter id="_the_language">
<title>The language.</title>
<simpara>This chapter will be a little introduction to ClojureScript without assumptions about previous
knowledge of the Clojure language, providing a quick tour over all the things you will need to know
in order to understand the rest of this book.</simpara>
<section id="_first_steps_with_lisp_syntax">
<title>First steps with lisp syntax</title>
<simpara>Invented by John McCarthy in 1958, Lisp is one of the oldest programming languages that is still
around. It has evolved into a whole lot of derivatives called dialects and ClojureScript is
one of them. It&#8217;s a programming language written in its own data structures, originally lists enclosed in
parenthesis, but Clojure(Script) has evolved the Lisp syntax with more data structures making
it more pleasant to write and read.</simpara>
<simpara>A list with a function in the first position is used for calling a function in ClojureScript:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(+ 1 2 3)
;; =&gt; 6</programlisting>
<simpara>In the example above we&#8217;re applying the addition function <literal>+</literal> to the arguments 1, 2 and 3. ClojureScript
allows many unusual characters like <literal>?</literal> or <literal>-</literal> in symbol names which makes it easier to read:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(zero? 0)
;; =&gt; true</programlisting>
<simpara>For distinguishing function calls and lists, we can quote lists for turning off evaluation. The quoted
lists will be treat as data instead of as a function call:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">'(+ 1 2 3)
;; =&gt; (+ 1 2 3)</programlisting>
<simpara>ClojureScript uses more than lists for its syntax, the full details will be covered later but here is an
example of the usage of a vector (enclosed in brackets) for defining local bindings:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [x 1
      y 2
      z 3]
  (+ x y x))
;; =&gt; 6</programlisting>
<simpara>This is practically all the syntax we need to know for using not only ClojureScript, but any Lisp. Being
written in its own data structures (often referred to as homoiconicity) is a great property since the syntax
is uniform and simple; also, code generation via macros is easier than in any language, giving us
plenty of power for extending the language to our needs.</simpara>
</section>
<section id="_the_base_data_types">
<title>The base data types.</title>
<simpara>The ClojureScript language has a rich set of data types like most programmig languages. It provides
scalar datatypes that will be very familiar for you such as numbers, strings, floats. But, also
provides a great amount of others that maybe are not well known such as symbols, keywords, regex,
vars, atoms, volatiles&#8230;&#8203;</simpara>
<simpara><emphasis>ClojureScript</emphasis> embrases the host language, and as possible it uses the host provided types. In this
case: numbers and strings are used as is and them behaves in same way as in javascript.</simpara>
<section id="_numbers">
<title>Numbers</title>
<simpara>In <emphasis>ClojureScript</emphasis> the numbers includes both: integers and floating points. But, knowing that
<emphasis>ClojureScript</emphasis> is a guest language that compiles to javascript, having integers is an ilusion.
Because the javascript language treats all numbers as floating points values.</simpara>
<simpara>Like in any other languages, the numbers in <emphasis>ClojureScript</emphasis> are represented in following way:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">23
+23
-100
1.7
-2
33e8
12e-14
3.2e-4</programlisting>
</section>
<section id="_keywords">
<title>Keywords</title>
<simpara>Keywords in <emphasis>ClojureScript</emphasis> are objecs that always evaluate to themselves. Them are usually
used in map data structures for reprensent in a most efficient way to the keys.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">:foobar
:2
:?
:foo/bar</programlisting>
<simpara>As you can see, the keyword are all prefixed with <literal>:</literal>, but this char is only part
of literal syntax and is not part of the name of the object.</simpara>
<simpara>You also can create a keyword calling a function <literal>keyword</literal>. Do not worry if you do not understand
or something is not clear in the following example, the functions are discussed some chapters
below.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(keyword "foo")
;; =&gt; :foo</programlisting>
</section>
<section id="_symbols">
<title>Symbols</title>
<simpara>The symbols in <emphasis>ClojureScript</emphasis> are very very similar to now known <emphasis role="strong">Keywords</emphasis>. But them
instead of evaluating to themselves, are evalutated to something that them refers, that
can be function, variables, &#8230;&#8203;</simpara>
<simpara>Them are represented with something that not star with a number</simpara>
<programlisting language="clojure" linenumbering="unnumbered">sample-symbol
othersymbol
f1</programlisting>
<simpara>Do not worry if you do not understand clearly this part, symbols are used un almost
all examples and you will have the oportunity to undesarstand them in a practical way,
with examples.</simpara>
</section>
<section id="_strings">
<title>Strings</title>
<simpara>Nothing new we can explain about strings that you do not known. In <emphasis>ClojureScript</emphasis> them
are work like in any other language. Them are immutable.</simpara>
<simpara>And in this concrete case are the same as in javascript:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">"A example of a string"</programlisting>
<simpara>The pecularity of Strings on <emphasis>ClojureScript</emphasis> is due to lisp syntax, and is that you don&#8217;t need
additional syntax for multiline strings:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">"This is a multiline
      string in ClojureScript."</programlisting>
</section>
<section id="_characters">
<title>Characters</title>
<simpara><emphasis>ClojureScript</emphasis> also has a representation for one character and it has a literal syntax for represent
them.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">\a        ; The lowercase a character
\newline  ; The new line character</programlisting>
<simpara>As its host does not a clear representation for character type, in <emphasis>ClojureScript</emphasis> behind the scenes
one character is a simple string with one character.</simpara>
</section>
<section id="_collections">
<title>Collections</title>
<simpara>As usual, the second big step on explaining one language, is explain its collections and collection
abstractions. The <emphasis>ClojureScript</emphasis> is not an exception in this rule.</simpara>
<simpara><emphasis>ClojureScript</emphasis> comes with great bunch of different collections. The main difference of <emphasis>ClojureScript</emphasis>
collections with other languages is that them are persistent and immutable.</simpara>
<simpara>But before venture of all these (maybe) unknown concepts, we&#8217;ll go to make a high level overview
of existing collection types in <emphasis>ClojureScript</emphasis>.</simpara>
<section id="_lists">
<title>Lists</title>
<simpara>This is a clasic collection type in lisp languages. <emphasis>ClojureScript</emphasis> is not an exception. List is the
simplest collection data structure in <emphasis>ClojureScript</emphasis>. Lists can contain items of any type, including
other collections.</simpara>
<simpara>Lists in <emphasis>ClojureScript</emphasis> are repsesented with parentheses as its literal syntax:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">'(1 2 3 4 5)
'(:foo :bar 2)</programlisting>
<simpara>As you can observe, all list examples are prefixed with <literal>'</literal> char. This is because lists in lisp like
languages are often used for express expressions forms such as function or macro calls. In that case
the first item should be a symbol that will evaluate to a something callable and the rest of list
elemenents will be a function parameters.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(inc 1)
;; =&gt; 2

'(inc 1)
;; =&gt; (inc 1)</programlisting>
<simpara>As you see, if you will evaluate the <literal>(inc 1)</literal> without prefixing it with <literal>'</literal> char, it will resolve
the <literal>inc</literal> symbol to the <emphasis role="strong">inc</emphasis> function and will execute it with <literal>1</literal> as first parameter. Resulting
in a <literal>2</literal> as return value.</simpara>
<simpara>Lists have the pecularity that they are very efficient if you access to it in a sequence mode or
access to its first elements but are not very good option if you need random (index) acces to its
elements.</simpara>
</section>
<section id="_vectors">
<title>Vectors</title>
<simpara>Like lists, <emphasis role="strong">Vectors</emphasis>  store a series of values, but in this case with very efficient index access
to its elements and its elements in difference with list are evaluated in order. Do not worry, in
below chapters we&#8217;ll go depth in details but at this moment is more that enough.</simpara>
<simpara>Vectors uses square brakets for the literal syntax, let see some examples:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">[:foo :bar]
[3 4 5 nil]</programlisting>
<simpara>Like lists, vectors can contain objects of any type, as you can observe the previos example.</simpara>
</section>
<section id="_maps">
<title>Maps</title>
<simpara>Maps is a collection abstraction that allows store unique keys associated with one value. In other
languages are commonly known as hash-maps or dicts. Maps in <emphasis>ClojureScript</emphasis> uses a
curly braces as literal syntax.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">{:foo "bar", :baz 2}
{:foobar [:a :b :c]}</programlisting>
<note>
<simpara>Commas are frequently used for separate a key value pair but are completelly optional. In
<emphasis>ClojureScript</emphasis> syntax, comas are treated like spaces.</simpara>
</note>
<simpara>Like Vectors, every item in a map literal is evaluated before the result is stored in a map, but
the order of evaluation is not guaranteed.</simpara>
</section>
<section id="_sets">
<title>Sets</title>
<simpara>And finally, <emphasis role="strong">Sets</emphasis>.</simpara>
<simpara>Sets stores in an unordered way zero or more unique items of any type. They,
like maps, uses curly braces for its literal syntax with difference that uses a <literal>#</literal> as leading
character:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">#{1 2 3 :foo :bar}</programlisting>
<simpara>In below chapters we&#8217;ll go depth in sets and other collection types explained in this chapter.</simpara>
</section>
</section>
</section>
<section id="_vars">
<title>Vars</title>
<simpara><emphasis>ClojureScript</emphasis> is a mostly functional language and focused in immutability. Becuase of that, it does
not has the concept of variables. The most closest analogy to variables are <emphasis role="strong">vars</emphasis>. The vars are
represented by symbols and stores a single value together with metadata.</simpara>
<simpara>You can define a var using a <literal>def</literal> special form:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def x 22)
(def y [1 2 3])</programlisting>
<simpara>The vars are always top level in the namespace. If you use <literal>def</literal> in a function call, the var will be defined
at the namespace level.</simpara>
</section>
<section id="_functions">
<title>Functions</title>
<section id="_the_first_contact_2">
<title>The first contact</title>
<simpara>It&#8217;s time of make things happen. In <emphasis>ClojureScript</emphasis>, a function are first-class type. It behaves
like any other type, you can pass it as parameter, you can return it as value, always respecting
the lexical scope. <emphasis>ClojureScript</emphasis> also has some features from dynamic scope but this will be discused
in other section.</simpara>
<simpara>If you want know more about scopes, this <ulink url="http://en.wikipedia.org/wiki/Scope_%28computer_science">wikipedia article</ulink>
is ver extensive and explain very well different types of scope.</simpara>
<simpara>As <emphasis>ClojureScript</emphasis> is a lisp dialect, it uses the prefix notation for calling a function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(inc 1)
;; =&gt; 2</programlisting>
<simpara>The <literal>inc</literal> is a function and is part of <emphasis>ClojureScript</emphasis> runtime, and <literal>1</literal> is a first positional
argument for the <literal>inc</literal> function.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(+ 1 2 3)
;; =&gt; 6</programlisting>
<simpara>The <literal>+</literal> symbol represents a <literal>add</literal> function, in ALGOL type of languages is an operator and only
allows two parameters.</simpara>
<simpara>The prefix notation has huge advantages, some of them not alwats obvious. <emphasis>ClojureScript</emphasis> does not
has distinction between a function and operator, everything is a function. The inmediate advantage
is that the prefix notation allows an arbitrary number of arguments per "operator". Also, it eliminates
per complete the problem of operator precedence.</simpara>
</section>
<section id="_defining_own_functions">
<title>Defining own functions</title>
<simpara>The function can be defined with <literal>fn</literal> special form. This is aspect of function definition:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(fn [param1 param2]
  (+ (inc param1) (inc param2)))</programlisting>
<simpara>You can define a function and call it in same time (in a single expression):</simpara>
<programlisting language="clojure" linenumbering="unnumbered">((fn [x] (inc x)) 1)
;; =&gt; 2</programlisting>
<simpara>Let start creating named functions. But that is means named function really? Is very simple,
as in <emphasis>ClojureScript</emphasis> functions are fist-class and behaves like any other value, naming a function
is just store it in a var:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def myinc (fn [x] (+ x 1)))

(myinc 1)
;; =&gt; 2</programlisting>
<simpara><emphasis>ClojureScript</emphasis> also offers the <literal>defn</literal> macro as a little sugar syntax for make function definition
more idiomatic:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn myinc
  "Self defined version of `inc`."
  [x]
  (+ x 1))</programlisting>
</section>
<section id="_function_with_multiple_arities">
<title>Function with multiple arities</title>
<simpara><emphasis>ClojureScript</emphasis> also comes with ability to define functions with arbitrary number of arities. The
syntax is almost the same as define standard function with the difference that it has more that
one body.</simpara>
<simpara>Let see an example, surelly it will explain it much better:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn myinc
  "Self defined version of parametrized `inc`."
  ([x] (myinc x 1))
  ([x increment]
   (+ x increment)))</programlisting>
<simpara>And there some examples using the previously defined multi arity function. I can observe that
if you call a function with wrong number of parameters the compiler will emit an error about that:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(myinc 1)
;; =&gt; 1

(myinc 1 3)
;; =&gt; 4

(myinc 1 3 3)
;; Compiler error</programlisting>
<note>
<simpara>Explaining the "arity" is out of scope of this book, however you can read about that in this
<ulink url="http://en.wikipedia.org/wiki/Arity">wikipedia article</ulink>.</simpara>
</note>
</section>
<section id="_variadic_functions">
<title>Variadic functions</title>
<simpara>An other way to accept multiple parameters is defining variadic functions. Variadic functions
are functions that will be able accept arbitrary number of arguments:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn my-variadic-set
  [&amp; params]
  (set params))

(my-variadic-set 1 2 3 1)
;; =&gt; #{1 2 3}</programlisting>
<simpara>The way to denone a variadic function is using the <literal>&amp;</literal> simbol prefix on its arguments vector.</simpara>
</section>
<section id="_short_syntax_for_anonymous_functions">
<title>Short syntax for anonymous functions</title>
<simpara><emphasis>ClojureScript</emphasis> provides a shorter syntax for define anonymos (and almost always one liner) functions
using the <literal>#()</literal> reader macro. Reader macros are "special" expressions that in compile time will be
transformed to the apropiate language form. In this case to some expression that uses <literal>fn</literal> special
form.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def my-set #(set %1 %2))

(my-set 1 2)
;; =&gt; #{1 2}</programlisting>
<simpara>The <literal>%1</literal>, <literal>%2</literal>, <literal>%N</literal> are simple markers for parameter positions that are implicitly declared when
the reader macro will be interpreted and converted to <literal>fn</literal> expression.</simpara>
<simpara>Also, if a function only accepts one argument, you can ommit the number after <literal>%</literal> symbol, the
function <literal>#(set %1)</literal> can be written <literal>#(set %)</literal>.</simpara>
<simpara>Additionaly, this syntax also supports the variadic form with <literal>%&amp;</literal> symbol:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def my-variadic-set #(set %&amp;))

(my-variadic-set 1 2 2)
;; =&gt; #{1 2}</programlisting>
</section>
</section>
<section id="_flow_control">
<title>Flow control</title>
<simpara><emphasis>ClojureScript</emphasis> has a great different approaches for flow control.</simpara>
<section id="_branching_with_literal_if_literal">
<title>Branching with <literal>if</literal></title>
<simpara>Let start with a basic one: <literal>if</literal>. In <emphasis>ClojureScript</emphasis> the <literal>if</literal> is an expression and not an
statement, and it has three parametes: first one the condition expression, the second one
a expression that will evalute if a condition expression will evalute in a logical true,
and the third one will evaluated otherwise.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn mypos?
  [x]
  (if (pos? x)
    "positive"
    "negative"))

(mypos? 1)
;; =&gt; "positive"

(mypos? -1)
;; =&gt; "negative"</programlisting>
<simpara>If you want do more that one thing in one of two expressions, you can use block expression <literal>do</literal>, that
is will explained in next section.</simpara>
</section>
<section id="_branching_with_literal_cond_literal">
<title>Branching with <literal>cond</literal></title>
<simpara>Sometimes, the <literal>if</literal> expression can be slightly limited because it does not have the "else if" part
for add more that one condition. The cond comes to the rescue.</simpara>
<simpara>With <literal>cond</literal> expression, you can define multiple conditions:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn mypos?
  [x]
  (cond
    (&gt; x 0) "positive"
    (&lt; x 0) "negative"
    :else "zero"))

(mypos? 0)
;; =&gt; "zero"

(mypos? -2)
;; =&gt; "negative"</programlisting>
<simpara>Also, cond has an other form, called <literal>condp</literal>, that works very similar to the simple <literal>cond</literal>
but looks more cleaner when a predicate is always the same for all conditions:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn translate-lang-code
  [code]
  (condp = (keyword code)
    :es "Spanish"
    :en "English"
    "Unknown"))

(translate-lang-code "en")
;; =&gt; "English"

(translate-lang-code "fr")
;; =&gt; "Unknown"</programlisting>
</section>
<section id="_branching_with_literal_case_literal">
<title>Branching with <literal>case</literal></title>
<simpara>The <literal>case</literal> branching expression has very similar use case that our previous example with
<literal>condp</literal>. The main difference is that, case always uses the <literal>=</literal> predicate/function and its
branching values are evaluated at compile time. This results in a more prerformant form
that <literal>cond</literal> or <literal>condp</literal> but has the disadvantage of that the condition value should be
a static value.</simpara>
<simpara>Let see the same example as previous one but using <literal>case</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn translate-lang-code
  [code]
  (case code
    "es" "Spanish"
    "es" "English"
    "Unknown"))

(translate-lang-code "en")
;; =&gt; "English"

(translate-lang-code "fr")
;; =&gt; "Unknown"</programlisting>
</section>
</section>
<section id="_locals_blocks_and_loops">
<title>Locals, Blocks and Loops</title>
<section id="_locals">
<title>Locals</title>
<simpara><emphasis>ClojureScript</emphasis> does not has the variables concepts, but it does have locals. Locals as per
usual, are immutable and if you try mutate them, the compiller will throw an error.</simpara>
<simpara>The locals are defined with <literal>let</literal> expression. It starts with a vector as first parameter
followed by arbitrary number of expresions. The first parameter should contain a arbitrary
number of pairs that starts with a binding form followed of an expression whose value will
be bound to this new local for the remainer of the let expression.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [x (inc 1)
      y (+ x 1)]
  (println "Simple message from the body of a let")
  (* x y))
;; Simple messages from the body of a let
;; =&gt; 6</programlisting>
</section>
<section id="_blocks">
<title>Blocks</title>
<simpara>The blocks in <emphasis>ClojureScript</emphasis> can be done using the <literal>do</literal> expression and is ususally used
for side effects, like printing something in console or write a log in a logger. Something
for that the return value is not necesary.</simpara>
<simpara>The <literal>do</literal> expression accept as parameter an arbitrary number of other expressions but return
the return value only from the last one:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(do
   (println "hello world")
   (println "hola mundo")
   (+ 1 2))
;; hello world
;; hola mundo
;; =&gt; 3</programlisting>
<simpara>The <literal>let</literal> expression, explained just in previous section, the body is very similar to the
<literal>do</literal> expression. In fact, it is called that is has an implicit <literal>do</literal>.</simpara>
</section>
<section id="_loops">
<title>Loops</title>
<simpara>The functional approach of <emphasis>ClojureScript</emphasis>, this causes that it does not have standard,
well known statements based loops. The loops in clojurescript are handled using recursion.
The recursion sometimes requires additional thinking about how model your problem in
a slightly different way than imperative languages.</simpara>
<simpara>Also, many of the common patterns for which <literal>for</literal> is used in other languages are achieved
through higher-order functions.</simpara>
<section id="_looping_with_loop_recur">
<title>Looping with loop/recur</title>
<simpara>Let&#8217;s take a look at how to express loops using recursions with the <literal>loop</literal> and <literal>recur</literal> forms.
<literal>loop</literal> defines a possibly empty list of bindings (notice the symmetry with <literal>let</literal>) and <literal>recur</literal>
jumps execution after the looping point with new values for those bindings.</simpara>
<simpara>Let&#8217;s see an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(loop [x 0]
   (println "Looping with " x)
   (if (= x 2)
     (println "Done looping!")
     (recur (inc x))))
;; Looping with 0
;; Looping with 1
;; Looping with 2
;; Done looping!
;; =&gt; nil</programlisting>
<simpara>In the above snippet, we bind the name <literal>x</literal> to the value <literal>0</literal> and execute the body. Since the
condition is not met the first time is run we <literal>recur</literal>, incrementing the binding value with
the <literal>inc</literal> function. We do this once more until the condition is met and, since there aren&#8217;t
more <literal>recur</literal> calls, exit the loop.</simpara>
<simpara>Note that <literal>loop</literal> isn&#8217;t the only point we can <literal>recur</literal> too, using <literal>recur</literal> inside a function
executes the body of the function recursively with the new bindings:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn recursive-function [x]
   (println "Looping with" x)
   (if (= x 2)
     (println "Done looping!")
     (recur (inc x))))

(recursive-function 0)
;; Looping with 0
;; Looping with 1
;; Looping with 2
;; Done looping!
;; =&gt; nil</programlisting>
</section>
<section id="_replacing_for_loops_with_higher_order_functions">
<title>Replacing for loops with higher-order functions</title>
<simpara>In imperative programming languages is common to use <literal>for</literal> loops for iterating over data and
transforming it, usually the intent being one of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Transform every value in the iterable yielding another iterable</simpara>
</listitem>
<listitem>
<simpara>Filter the elements of the iterable by a certain criteria</simpara>
</listitem>
<listitem>
<simpara>Convert the iterable to a value where each iteration depends on the result from the previous one</simpara>
</listitem>
<listitem>
<simpara>Run a computation for every value in the iterable</simpara>
</listitem>
</itemizedlist>
<simpara>The above actions are encoded in higher-order functions and syntactic constructs in ClojureScript,
let&#8217;s see an example of the first three.</simpara>
<simpara>For transforming every value in a iterable data structure we use the <literal>map</literal> function, which takes a
function and a sequence and applies the function to every element:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(map inc [0 1 2])
;; =&gt; (1 2 3)</programlisting>
<simpara>For filtering the values of a data structure we use the <literal>filter</literal> function, which takes a predicate
and a sequence and gives a new sequence with only the elements that returned <literal>true</literal> for the given
predicate:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(filter odd? [1 2 3 4])
;; =&gt; (1 3)</programlisting>
<simpara>Converting an iterable to a value accumulating the intermediate result in every step of the iteration
can be achieved with <literal>reduce</literal>, which takes a function for accumulating values, an optional initial value
and a collection:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(reduce + 0 [1 2 3 4])
;; =&gt; 10</programlisting>
</section>
<section id="__literal_for_literal_sequence_comprehensions">
<title><literal>for</literal> sequence comprehensions</title>
<simpara>In ClojureScript the <literal>for</literal> construct isn&#8217;t used for iteration but for generating sequences, an operation
also known as "sequence comprehension". It offers a small domain specific language for declaratively
building lazy sequences.</simpara>
<simpara>It takes a vector of bindings and a expression and generates a sequence of the result of evaluating the
expression, let&#8217;s take a look at an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(for [x [1 2 3]]
  [x x])
;; =&gt; ([1 1] [2 2] [3 3])</programlisting>
<simpara>It supports multiple bindings, which will cause the collections to be iterated in a nested fashion, much
like nesting <literal>for</literal> loops in imperative languages:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(for [x [1 2 3]
      y [4 5]]
  [x y])
;; =&gt; ([1 4] [1 5] [2 4] [2 5] [3 4] [3 5])</programlisting>
<simpara>We can also follow the bindings with three modifiers: <literal>:let</literal> for creating local bindings, <literal>:while</literal> for
breaking out of the sequence generation and <literal>:when</literal> for filtering out values.</simpara>
<simpara>Here&#8217;s an example of local bindings using the <literal>:let</literal> modifier, note that the bindings defined with it
will be available in the expression:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]]
  z)
;; =&gt; (5 6 6 7 7 8)</programlisting>
<simpara>We can use the <literal>:while</literal> modifier for expressing a condition that, when it is no longer met, will stop
the sequence generation. Here&#8217;s an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(for [x [1 2 3]
      y [4 5]
      :while (= y 4)]
  [x y])
;; =&gt; ([1 4] [2 4] [3 4])</programlisting>
<simpara>For filtering out generated values we use the <literal>:when</literal> modifier like in the following example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(for [x [1 2 3]
      y [4 5]
      :when (= (+ x y) 6)]
  [x y])
;; =&gt; ([1 5] [2 4])</programlisting>
<simpara>We can combine the modifiers shown above for expressing complex sequence generations or
more clearly expressing the intent of our comprehension:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]
      :when (= z 6)]
  [x y])
;; =&gt; ([1 5] [2 4])</programlisting>
<simpara>When we outlined the most common usages of the <literal>for</literal> construct in imperative programming languages
we mentioned that sometimes we want to run a computation for every value in a sequence, not caring
about the result. Presumably we do this for achieving some sort of side-effect with the values of
the sequence.</simpara>
<simpara>ClojureScript provides the <literal>doseq</literal> construct, which is analogous to <literal>for</literal> but executes the expression
discarding the resulting values and returns <literal>nil</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(doseq [x [1 2 3]
        y [4 5]
       :let [z (+ x y)]]
  (println x "+" y "=" z))
;; 1 + 4 = 5
;; 1 + 5 = 6
;; 2 + 4 = 6
;; 2 + 5 = 7
;; 3 + 4 = 7
;; 3 + 5 = 8
;; =&gt; nil</programlisting>
</section>
</section>
</section>
<section id="_collection_types">
<title>Collection types</title>
<section id="_immutable_and_persistent">
<title>Immutable and persistent</title>
<simpara>We mentioned before that ClojureScript collections are persistent and immutable but didn&#8217;t explain what
we meant.</simpara>
<simpara>An immutable data structure, as its name suggest, is a data structure that can not be changed. In-place
updates are not allowed in immutable data structures.</simpara>
<simpara>A persistent data structure is a data structure that returns a new version of itself when transforming
it, leaving the original unmodified. ClojureScript makes this memory and time efficient using an
implementation technique called structural sharing, where most of the data shared between two versions
of a value is shared and transformations of a value are implemented by copying the minimal amount of data
required.</simpara>
<simpara>Let&#8217;s see an example of appending values to a vector using the <literal>conj</literal> (for "conjoin") operation:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [xs [1 2 3]
      ys (conj xs 4)]
  (println "xs:" xs)
  (println "ys:" ys))
;; xs: [1 2 3]
;; ys: [1 2 3 4]
;; =&gt; nil</programlisting>
<simpara>As you can see, we derived a new version of the <literal>xs</literal> vector appending an element to it and got a new
vector <literal>ys</literal> with the element added.</simpara>
<simpara>For illustrating the structural sharing of ClojureScript data structures, let&#8217;s compare whether some parts
of the old and new versions of a data structure are actually the same object with the <literal>identical?</literal> predicate.
We&#8217;ll use the list data type for this purpose:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [xs (list 1 2 3)
      ys (cons 0 xs)]
  (println "xs:" xs)
  (println "ys:" ys)
  (println "(rest ys):" (rest ys))
  (identical? xs (rest ys)))
;; xs: (1 2 3)
;; ys: (0 1 2 3)
;; (rest ys): (1 2 3)
;; =&gt; true</programlisting>
<simpara>As you can see in the example, we used <literal>cons</literal> (construct) to prepend a value to the <literal>xs</literal> list and we got
a new list <literal>ys</literal> with the element added. The <literal>rest</literal> of the <literal>ys</literal> list (all the values but the first)
are the same object in memory that the <literal>xs</literal> list, thus <literal>xs</literal> and <literal>ys</literal> share structure.</simpara>
</section>
<section id="_the_sequence_abstraction">
<title>The sequence abstraction</title>
<simpara>One of the central ClojureScript abstractions is the Sequence, which can be though as a list and can be derived
from any of the collection types. It is persistent and immutable like all collection types and many of the
core ClojureScript functions return sequences.</simpara>
<simpara>The types that can be used to generate a sequence are called "seqables", we can call <literal>seq</literal> on them and get
a sequence back. Sequences support two basic operations: <literal>first</literal> and <literal>rest</literal>. They both call <literal>seq</literal> on the
argument we provide them:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(first [1 2 3])
;; =&gt; 1

(rest [1 2 3])
;; =&gt; (2 3)</programlisting>
<simpara>Calling <literal>seq</literal> on a seqable can yield different results if the seqable is empty or not, it will return <literal>nil</literal>
when empty and a sequence otherwise:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(seq [])
;; =&gt; nil

(seq [1 2 3])
;; =&gt; (1 2 3)</programlisting>
<simpara><literal>next</literal> is a similar sequence operation to <literal>rest</literal>, but it differs from the latter in that it yields a <literal>nil</literal> value
when called with a sequence with one or zero elements. Note that, when given one of the aforementioned sequences,
the empty sequence returned by <literal>rest</literal> will evaluate as a boolean true whereas the <literal>nil</literal> value returned by <literal>next</literal>
will evaluate as false:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(rest [])
;; =&gt; ()

(next [])
;; =&gt; nil

(rest [1 2 3])
;; =&gt; (2 3)

(next [1 2 3])
;; =&gt; (2 3)</programlisting>
<section id="_nil_punning">
<title>nil-punning</title>
<simpara>The above behaviour of <literal>seq</literal> coupled with the falsey nature of <literal>nil</literal> in boolean contexts make an idiom for checking
the emptyness of a sequence in ClojureScript, which is often referred to as nil-punning.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn print-coll
  [coll]
  (when (seq coll)
    (println "Saw " (first coll))
    (recur (rest coll))))

(print-coll [1 2 3])
;; Saw 1
;; Saw 2
;; Saw 3
;; =&gt; nil

(print-coll #{1 2 3})
;; Saw 1
;; Saw 3
;; Saw 2
;; =&gt; nil</programlisting>
<simpara><literal>nil</literal> is also both a seqable and a sequence, and thus it supports all the functions we saw so far:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(seq nil)
;; =&gt; nil

(first nil)
;; =&gt; nil

(rest nil)
;; =&gt; ()</programlisting>
</section>
<section id="_functions_that_work_on_sequences">
<title>Functions that work on sequences</title>
<simpara>The ClojureScript core functions that work on collections call <literal>seq</literal> on their arguments, thus being
implemented in terms of generic sequence operations. This also makes them short-circuit when encountering empty
collections and being <literal>nil</literal>-safe.</simpara>
<simpara>We already saw examples with the usual suspects like <literal>map</literal>, <literal>filter</literal> and <literal>reduce</literal> but ClojureScript offers a
plethora of generic sequence operations in its core namespace. Note that many of the operations we&#8217;ll learn about
either work with seqables or are extensible to user defined types.</simpara>
<simpara>We can query a value to know wheter it&#8217;s a collection type with the <literal>coll?</literal> predicate:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(coll? nil)
;; =&gt; false

(coll? [1 2 3])
;; =&gt; true

(coll? {:language "ClojureScript" :file-extension "cljs"})
;; =&gt; true

(coll? "ClojureScript")
;; =&gt; false</programlisting>
<simpara>Similar predicates exist for checking if a value is sequence (<literal>seq?</literal>) or a seqable (<literal>seqable?</literal>):</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(seq? nil)
;; =&gt; false
(seqable? nil)
;; =&gt; false

(seq? [])
;; =&gt; false
(seqable? [])
;; =&gt; true

(seq? #{1 2 3})
;; =&gt; false
(seqable? #{1 2 3})
;; =&gt; true

(seq? "ClojureScript")
;; =&gt; false
(seqable? "ClojureScript")
;; =&gt; false</programlisting>
<simpara>For collections that can be counted in constant time, we can use the <literal>count</literal> operation:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(count nil)
;; =&gt; 0

(count [1 2 3])
;; =&gt; 3

(count {:language "ClojureScript" :file-extension "cljs"})
;; =&gt; 2

(count "ClojureScript")
;; =&gt; 13</programlisting>
<simpara>We can also get an empty variant of a given collection with the <literal>empty</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(empty nil)
;; =&gt; nil

(empty [1 2 3])
;; =&gt; []

(empty #{1 2 3})
;; =&gt; #{}</programlisting>
<simpara>The <literal>empty?</literal> predicate returns true if the given collection is empty:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(empty? nil)
;; =&gt; true

(empty? [])
;; =&gt; true

(empty? #{1 2 3})
;; =&gt; false</programlisting>
<simpara>The <literal>conj</literal> operation adds elements to collections and may add them in different "places" depending
on the collection. It adds them where it makes more sense for the given collection performance-wise,
but note that not every collection has a defined order.</simpara>
<simpara>We can pass as many elements we want to add to <literal>conj</literal>, let&#8217;s see it in action:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(conj nil 42)
;; =&gt; (42)

(conj [1 2] 3)
;; =&gt; [1 2 3]

(conj [1 2] 3 4 5)
;; =&gt; [1 2 3 4 5]

(conj '(1 2) 0)
;; =&gt; (0 1 2)

(conj #{1 2 3} 4)
;; =&gt; #{1 3 2 4}

(conj {:language "ClojureScript"} [:file-extension "cljs"])
;; =&gt; {:language "ClojureScript", :file-extension "cljs"}</programlisting>
</section>
<section id="_lazyness">
<title>Lazyness</title>
<simpara>TODO</simpara>
</section>
</section>
<section id="_collections_in_depth">
<title>Collections in depth</title>
<section id="_lists_2">
<title>Lists</title>

</section>
<section id="_vectors_2">
<title>Vectors</title>

</section>
<section id="_maps_2">
<title>Maps</title>

</section>
<section id="_sets_2">
<title>Sets</title>

</section>
</section>
</section>
<section id="_destructuring">
<title>Destructuring</title>
<simpara>TBD</simpara>
</section>
<section id="_namespaces">
<title>Namespaces</title>
<section id="_defining_a_namespace">
<title>Defining a namespace</title>
<simpara>Namespaces is a clojurescript&#8217;s fundamental unit of code modularity. Are analogous to Java packages or
Ruby and Python modules, and can be defined with <literal>ns</literal> macro. Maybe if you are touched a little bit of
clojurescript source you have seen something like this at begining of the file:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.core
  "Some docstring for the namespace.")

(def x "hello")</programlisting>
<simpara>Namespaces are dynamic and you can create one in any time, but the convention is having one namespace
per file. So, the namespace definition usually is at begining of the file followed with optional
docstring.</simpara>
<simpara>Previously we have explained the vars and symbols. Every var that you are defines will be associated
with one namespace. If you do not define a concrete namespace, the default one called "user" will be
used:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def x "hello")
;; =&gt; #'user/x</programlisting>
</section>
<section id="_loading_other_namespaces">
<title>Loading other namespaces</title>
<simpara>It&#8217;s ok, definining a namespace and vars in it is really easy, but it is not very usefull if we can&#8217;t
use them from other namespaces. For this purpose, the <literal>ns</literal> macro also offers a simple way to load other
namespaces.</simpara>
<simpara>Observe the following:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.main
  (:require myapp.core
            clojure.string))

(clojure.string/upper-case myapp.core/x)
;; =&gt; "HELLO"</programlisting>
<simpara>As you can observe, we are using fully qualified names (namespace + var name) for access to vars and
functions from different namespaces.</simpara>
<simpara>It is ok, we not can access to other namespaces but is very boring always write the complete namespace
name for access to its vars and functions. It will be specially uncomfortable if a namespace name
is very large. For solve that, you can use the <literal>:as</literal> directive for create an additional (usually
more shorter) alias to the namespace. Let see the how it can be done:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.main
  (:require [myapp.core :as core]
            [clojure.string :as str]))

(str/upper-case core/x)
;; =&gt; "HELLO"</programlisting>
<simpara>Additionaly, <emphasis>ClojureScript</emphasis> offers a simple way to refer specific vars or functions from concrete namespace using the <literal>:refer</literal> directive.</simpara>
<simpara>The <literal>:refer</literal> directive has two possible arguments: <literal>:all</literal> keyword or a vector of symbols that will
refer to vars in the namespace. With <literal>:all</literal> we are indicating that we want refer all public vars from the
namespace and with vector we can specify the concrete subset of vars that we want.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.main
  (:require [myapp.core :refer :all]
            [clojure.string :refer [upper-case]]))</programlisting>
<simpara>And finally, we should know that everything that located in the <literal>cljs.core</literal> namespace is automatically
loaded and you should not require it explicitly. But sometimes you want declare vars that will clash
with some other defined in <literal>cljs.core</literal> namespace. For it, the <literal>ns</literal> macro offers an other directive that
allows exclude concrete symbols and prevet them to be automaticaly loaded.</simpara>
<simpara>Observe the following:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.main
  (:refer-clojure :exclude [min]))

(defn min
  [x y]
  (if (&gt; x y)
    y
    x))</programlisting>
<simpara>The <literal>ns</literal> macro also has other directives for loading host clases (<literal>:import</literal>) and macros
(<literal>:refer-macros</literal>), but them are explained in posterior sections.</simpara>
</section>
</section>
<section id="_abstractions_and_polymorphism">
<title>Abstractions and Polymorphism</title>
<simpara>I&#8217;m sure that in more that in one time you have found in this situation: you have defined a great
abstraction (using interfaces or something similar) for your "bussines logic" and you have found
the need to deal with an other module over which you have absolutelly no control, and you probably
was thinking in create adapters, proxies and other approaches that will implies a great amount
of additional complexity.</simpara>
<simpara>Some dynamic languages allows "monkey-patching", languages where the classes are open and any
method can be defined and redefined at any time. Also, is very known that this technique is a very
bad practice.</simpara>
<simpara>We can not trust languages that allows that when importing third party libraries, can silently overwrite
methods that you are using and expecting a concrete behavior.</simpara>
<simpara>This symptoms denotes a commonly named: "Expression problem".</simpara>
<simpara>TODO: add link to expression problem description</simpara>
<section id="_protocols">
<title>Protocols</title>
<simpara>The <emphasis>ClojureScript</emphasis> primitive for define "interfaces" are called Protocols. A protocol consists in
a name and set of functions. All functions have at least one argument corresponding to the
<literal>this</literal> in javascript or <literal>self</literal> in Python.</simpara>
<simpara>Protocols provides a type based polymorphism, and the dispatch is always done by the
first argument previously mentioned as <literal>this</literal>.</simpara>
<simpara>A protocol looks like this:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.foobar)

(defprotocol IProtocolName
  "A docstring describing the protocol."
  (sample-method [this] "A doc string of the function associated with the protocol."))</programlisting>
<note>
<simpara>the "I" prefix is very common for make clear separation of protocols and types. In clojute
comunity it there many dispare optionions about the use of the "I" prefix. In our opinion is an
acceptable solution for avoid name clashing and confusions.</simpara>
</note>
<simpara>From the user perspective, protocol functions are simple and plain functions defined in the namespace
where the protocol is defined. As you can intuit, this makes protocols completelly namespaces and
avoid any accidental clashing between implemented protocols for same type.</simpara>
<section id="_extending_to_existing_types">
<title>Extending to existing types</title>
<simpara>On of the big strengths of protocols is the ability to extend existing and maybe third party types
and this operation can be done in different ways. The majority of time you will be tend to use
the <emphasis role="strong">extend-protocol</emphasis> or the <emphasis role="strong">extend-type</emphasis> macros.</simpara>
<simpara>This is the aspect on how <emphasis role="strong">extend-type</emphasis> macro can be used:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type TypeA
  ProtocolA
  (function-from-protocol-a [this]
    ;; implementation here
    )

  ProtocolB
  (function-from-protocol-b-1 [this parameter1]
    ;; implementation here
    )
  (function-from-protocol-b-2 [this parameter1 parameter2]
    ;; implementation here
    ))</programlisting>
<simpara>You can observe that with <emphasis role="strong">extend-type</emphasis> you are extending one type with different protocols
in one expression. In difference to that, <emphasis role="strong">extend-protocol</emphasis> do just the inverse operation. It,
given a protocol, add implementation for it to multiple types:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-protocol ProtocolA
  TypeA
  (function-from-protocol-a [this]
    ;; implementation here
    )

  TypeB
  (function-from-protocol-a [this]
    ;; implementation here
    ))</programlisting>
<simpara>It there other ways to extend a type with a protocol implementation but them will be covered
in other section of this book.</simpara>
</section>
<section id="_participate_in_clojurescript_abstractions">
<title>Participate in ClojureScript abstractions</title>
<simpara>ClojureScript it self is built up on abstractions defined as protocols, so almost all behavior
in the <emphasis>ClojureScript</emphasis> language can be adopted for third party libraries. Let&#8217;s go to see an
real life example.</simpara>
<simpara>In previous sections we have explained different kind of builtin collections, in this case we
will use the <emphasis role="strong">Set</emphasis>'s. See this snipped of code:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def mynums #{1 2})

(filter mynums [1 2 4 5 1 3 4 5])
;; =&gt; (1 2 1)</programlisting>
<simpara>But, that it happens where? In this case, the set type implements the <emphasis>ClojureScript</emphasis> internal
<literal>IFn</literal> protocol that represents an abstraction for functions or any thing callable. So it can be
used like a callable predicate in filter.</simpara>
<simpara>Ok, but what it happens if we want use a regular expression as predicate function for filter
a collection of strings:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(filter #"^foo" ["haha" "foobar" "baz" "foobaz"])
;; TypeError: Cannot call undefined</programlisting>
<simpara>Obviosly, this exception is raised because the RegExp type does not implements the <literal>IFn</literal> protocol
so it can not behave like a callable. But it can be easy fixed:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(extend-type js/RegExp
  IFn
  (-invoke
   ([this a]
     (re-find this a))))</programlisting>
<simpara>Now, you will be able use the regex instances as predicates in filter operation:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(filter #"^foo" ["haha" "foobar" "baz" "foobaz"])
;; =&gt; ("foobar" "foobaz")</programlisting>
</section>
<section id="_protocols_introspection">
<title>Protocols introspection</title>
<simpara><emphasis>ClojureScript</emphasis> comes with a usefull function that allows runtime introspection: <literal>satisfies?</literal>. The
purpose of this function is know in runtime if some object (instance of some type) satisfies the
concrete protocol.</simpara>
<simpara>So, with previous examples, if we check if a set instance satisfies a <emphasis role="strong">IFn</emphasis> protocol, it should
return <literal>true</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(satisfies IFn #{1})
;; =&gt; true</programlisting>
</section>
</section>
<section id="_multimethods">
<title>Multimethods</title>
<simpara>We have previously talked about protocols, that solves a very common use case of polymorphism:
dispatch by type. But in some circumstances the protocol&#8217;s approach it can be limiting. And
here <emphasis role="strong">multimethods</emphasis> comes to the rescue.</simpara>
<simpara>The <emphasis role="strong">multimethods</emphasis> are not limited to type dispatch only, instead, them also offers dispatch
by types of multiple arguments, by value and allows ad-hoc hierarchies to be defined. Also,
like protocols, is a "Open System" so you or any third parties can extend a multimethod for
new types.</simpara>
<simpara>The basic consturctions of <emphasis role="strong">multimethods</emphasis> consists in <literal>defmulti</literal> and <literal>defmethod</literal> forms. The
<literal>defmulti</literal> form is used for create the multimethod with initial dispatch function. This is
a common look and feel of it:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defmulti say-hello
  "A polymorphic function that return a greetings message
  depending on the language key with default lang as `:en`"
  (fn [param] (:locale param))
  :default :en)</programlisting>
<simpara>The anonymous function defined within the <literal>defmulti</literal> form is a dispatch function. It will
be called in every call to <literal>say-hello</literal> function and should return some kind of mark object
that will be used for dispatch. In our example it returns the contents of <literal>:locale</literal> key
of the first argument.</simpara>
<simpara>And finally, we should add implementations. That is done with <literal>defmethod</literal> form:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defmethod say-hello :en
  [person]
  (str "Hello " (:name person "Anonymous")))

(defmethod say-hello :es
  [person]
  (str "Hola " (:name person "Anonimo")))</programlisting>
<simpara>So, if you execute that function over a hash map containing the <literal>:locale</literal> and optionally
the <literal>:name</literal> key, the multimethod firstly will call the dispatch function for determine the
dispatch value, secondly it will search an implementation for that value, if it is found,
it will execute it, in case contrary it will search the default implementation (if it
specified) and execute it.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(say-hello {:locale :es})
;; =&gt; "Hola Anonymo"

(say-hello {:locale :en :name "Ciri"})
;; =&gt; "Hello Ciri"

(say-hello {:locale :fr})
;; =&gt; "Hello Anonymous"</programlisting>
<simpara>If the default implementation is not specified, an exception will be raised notifying about
that some value does not have a implementation for that multimethod.</simpara>
</section>
<section id="_hierarchies">
<title>Hierarchies</title>
<simpara>Hierarchies is a way that <emphasis>ClojureScript</emphasis> offers you build a whatever relations that your
domain may require. The hierarchies are difined in term of relations betwen named objects,
such as symbols, keywords or types.</simpara>
<simpara>The hierarchies can be defined globally or locally, depending on your needs. Like multimethods,
hierarchies are not limited to single namespace. You can extend a hierarchy from any namespace,
not necesary the one which they are defined.</simpara>
<simpara>The global namespace is more limited, for good reasons. Not namespaced keywords or symbols can
not be used in the global hierarcy. That behavior helps prevent unexpected situations when
two or more third party libraries uses the same symbol for different semantics.</simpara>
<section id="_defining_a_hierarchy">
<title>Defining a hierarchy</title>
<simpara>The hierarchy relations should be established using <literal>derive</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(derive ::circle ::shape)
(derive ::box ::shape)</programlisting>
<simpara>We have just defined a set of relationships between namespaced keywords, in this case the
<literal>::circle</literal> is a child of <literal>::shape</literal> and <literal>::box</literal> is also a child of <literal>::shape</literal>.</simpara>
<tip>
<simpara>The <literal>::circle</literal> keyword syntax is a shortland for <literal>:current.ns/circle</literal>. So if you are executing
it in a repl, sureally that <literal>::circle</literal> will be evaluated to <literal>:cljs.user/circe</literal>.</simpara>
</tip>
</section>
<section id="_hierarchies_introspection">
<title>Hierarchies introspection</title>
<simpara><emphasis>ClojureScript</emphasis> comes with little toolset of functions that allow runtime introspection
of the global or local defined hierarchies. These toolset consists on thre functions:
<literal>isa?</literal>, <literal>anscestors</literal>, and <literal>descendants</literal>.</simpara>
<simpara>Let see an example on how it can be used with hierarchy defined in previous example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ancestors ::box)
;; =&gt; #{:cljs.user/shape}

(descendants ::shape)
;; =&gt; #{:cljs.user/circle :cljs.user/box}

(isa? ::box ::shape)
;; =&gt; true

(isa? ::rect ::shape)
;; =&gt; false</programlisting>
</section>
<section id="_local_defined_hierarchies">
<title>Local defined hierarchies</title>
<simpara>As we mentioned previously, in <emphasis>ClojureScript</emphasis> you also can define local hierarchies. This can be
done with <literal>make-hierarchy</literal> function. And this is the aspect of how you can replicate the previous
example but using the local hierarchy:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def h (-&gt; (make-hierarchy)
           (derive :box :shape)
           (derive :circle :shape)))</programlisting>
<simpara>Now, if you can use the same introspection functions with that, locally defined hierarchy:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(isa? h :box :shape)
;; =&gt; true

(isa? :box :shape)
;; =&gt; false</programlisting>
<simpara>As you can observe, in local hierarchies we can use normal (not namespace qualified) keywords
and if we execute the <literal>isa?</literal> without passing the local hierarchy parameter, its as expected
return false.</simpara>
</section>
<section id="_hierarchies_in_multimethods">
<title>Hierarchies in multimethods</title>
<simpara>One of the big advantages of hierarchies, is that they works very well together with multimethods.
Because, multimethods by default uses the <literal>isa?</literal> function for the last step of dispatching.</simpara>
<simpara>Let see an example for clearly understand that it means. Firstly define the multimethod with
<literal>defmulti</literal> form:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defmulti stringify-shape
  "A function that prints a human readable representation
  of a shape keyword."
  identity
  :hierarchy h)</programlisting>
<simpara>With <literal>:hierarchy</literal> keyword parameter we indicate to the multimethod that hierarchy we want to use,
if it is not specified, the global hierarchi will be used.</simpara>
<simpara>Secondly, define a implementation for our multimethod using the <literal>defmethod</literal> form:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defmethod stringify-shape :box
  [_]
  "A box shape")

(defmethod stringify-shape :shape
  [_]
  "A generic shape")

(defmethod stringify-shape :default
  [_]
  "Unexpected object")</programlisting>
<simpara>Now, let see what is happens if we execute that function with a box:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(stringify-shape :box)
;; =&gt; "A box shape"</programlisting>
<simpara>Now everything works as expected, the multimethod executes the direct matching implementation
for the given parameter. But that is happens if we execute the same function but with <literal>:circle</literal>
keyword as parameter, that does not have the direct matching dispatch value:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(stringify-shape :circle)
;; =&gt; "A generic shape"</programlisting>
<simpara>The multimethod automatically resolves it using the provided hierarchy, and that <literal>:circle</literal> is
a descendat of <literal>:shape</literal>, so the <literal>:shape</literal> implementation is executed.</simpara>
</section>
</section>
</section>
<section id="_data_types">
<title>Data types</title>
<simpara>Until, now, we have used maps, sets, lists and vectors for represent our data. And in most cases is a
really great aproach for do it. But some times we need define our own types and in this book we will
call them <emphasis role="strong">datatypes</emphasis>.</simpara>
<simpara>A datatype provides the following:</simpara>
<itemizedlist>
<listitem>
<simpara>A unique host backed type, either named or anonymous.</simpara>
</listitem>
<listitem>
<simpara>Explicitly declared structure using fields or closures.</simpara>
</listitem>
<listitem>
<simpara>Implement concrete abstractions.</simpara>
</listitem>
<listitem>
<simpara>Map like behavior (via records, see below).</simpara>
</listitem>
</itemizedlist>
<section id="_deftype">
<title>Deftype</title>
<simpara>The most low level construction in <emphasis>ClojureScript</emphasis> for create own types, is the <literal>deftype</literal> macro. For
demostration we will define a type called <literal>User</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(deftype User [firstname lastname])</programlisting>
<simpara>Once the type has beed defined, we can create an instance of our <literal>User</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def user (User. "Triss" "Merigold"))</programlisting>
<simpara>And its fields can be accesset using the prefix-dot notation:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(.-firstname user)
;; =&gt; "Triss"</programlisting>
<simpara>Types defined with deftype (and posteriory with defrecord) creates a host backed class like object
associated to the current namespace. But it has some peculiarities when we intend to use or import
it from other namespace. The types in <emphasis>ClojureScript</emphasis> should be imported with <literal>:import</literal> directive
of <literal>ns</literal> macro:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myns.core
  (:import otherns.User))

(User. "Cirilla" "Fiona")</programlisting>
<simpara>For convenience, <emphasis>ClojureScript</emphasis> also defines a constructor function caled <literal>&#8594;User</literal> that can be imported
with the common way using <literal>:require</literal> directive.</simpara>
<simpara>We personally do not like this type of functions, and we prefer define own constructors, with more
idiomatic names:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn user
  [firstname lastname]
  (User. firstname lastname))</programlisting>
<simpara>And use it in our code instead of <literal>&#8594;User</literal>.</simpara>
</section>
<section id="_defrecord">
<title>Defrecord</title>
<simpara>The record is a slightly higher level abstraction for define types in <emphasis>ClojureScript</emphasis> and should be
prefered way to do it.</simpara>
<simpara>As we know, <emphasis>ClojureScript</emphasis> tends to use plain data types how are the maps but in most cases we need
have a named type for represent the entities of our application. Here come the records.</simpara>
<simpara>A record is a datatype that implements a map protocols and therefore can be used like any other map.
And since records are also proper types, they support type-based polymorphism through protocols.</simpara>
<simpara>In summary: with records, we have the best of both worlds, maps that can play in in different
abstractions.</simpara>
<simpara>Let start defining the <literal>User</literal> type but using records:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defrecord User [firstname lastname])</programlisting>
<simpara>It looks really similar to deftype syntax, in fact, it uses deftype behind the scenes as low level
primitive for defining types.</simpara>
<simpara>Now, look the difference with raw types for access to its fields:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def user (User. "Yennefer" "of Vengerberg"))

(:username user)
;; =&gt; "Yennefer"

(get user :username)
;; =&gt; "Yennefer"</programlisting>
<simpara>As we mention previously, records are maps and acts like tham:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(map? user)
;; =&gt; true</programlisting>
<simpara>And like maps, tham support extra fields that are not initially defined:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def user2 (assoc user :age 92))

(:age user2)
;; =&gt; 92</programlisting>
<simpara>As we can see, the <literal>assoc</literal> function works as is expected and return a new instance of the same
type but with new key value pair. But take care with <literal>dissoc</literal>, its behavior with records is slightly
different that with maps; it will return a new record if the field being dissociated is an optional
field, but it will return a plain map if you dissociate the mandatory field.</simpara>
<simpara>An other difference with maps is that records does not acts like functions:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def plain-user {:username "Yennefer", :lastname "of Vengerberg"})

(plain-user :username)
;; =&gt; "Yennefer"

(user :username)
;; =&gt; user.User does not implements IFn protocol.</programlisting>
<simpara>The <literal>defrecord</literal> macro like the <literal>deftype</literal>, for convenience esposes <literal>&#8594;User</literal> function, but with additional
one <literal>map&#8594;User</literal> constructor function. We have the same opionon about that constructors that with
deftype defined ones: we recommend define own instead of use that ones. But as they exists, let see
how they can be used:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def cirilla (-&gt;User "Cirilla" "Fiona"))
(def yen (map-&gt;User {:firstname "Yennefer"
                     :lastname "of Vengerberg"}))</programlisting>
</section>
<section id="_implement_protocols">
<title>Implement protocols</title>
<simpara>Both type definition primitives that we have seen until now allows inline implementations for protocols
(explained in previous section). Let start define one for example purposes:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defprotocol IUser
  "A common abstraction for work with user types."
  (full-name [_] "Get the full name of the user."))</programlisting>
<simpara>Now, you can define a type with inline implementation for an abstraction, in our case the <literal>IUser</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defrecord User [firstname lastname]
  IUser
  (full-name [_]
    (str firstname " " lastname)))

;; Create an instance.
(def user (User. "Yennefer" "of Vengerberg"))

(full-name user)
;; =&gt; "Yennefer of Vengerberg"</programlisting>
</section>
<section id="_reify">
<title>Reify</title>
<simpara>The <literal>reify</literal> macro lets you create an anonymous types that implement protocols. In difference with
deftype and defrecord, it does not has accessible fields.</simpara>
<simpara>This is a way how we can emulate an instance of user type and that plays well in <literal>IUser</literal> abstraction:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn user
  [firstname lastname]
  (reify
    IUser
    (full-name [_]
      (str firstname " " lastname))))

(def yen (user "Yennefer" "of Vengerberg"))
(full-name user)
;; =&gt; "Yennefer of Vengerberg"</programlisting>
<simpara>The real purpose of reify is create anonymous types that plains in a concrete abstractions but
you do not want a type in self.</simpara>
</section>
</section>
<section id="_host_interoperability">
<title>Host interoperability</title>
<simpara><emphasis>ClojureScript</emphasis> in the same way as it brother Clojure, is designed to be a "Guest" language. It means
that the design of the language fits very well to work on to of existing ecosystem such as javascript
for <emphasis>ClojureScript</emphasis> and jvm for <emphasis>Clojure</emphasis>.</simpara>
<section id="_the_types">
<title>The types.</title>
<simpara><emphasis>ClojureScript</emphasis> unlike expected, try takes advantage of every type that the platform provides. This
is a maybe incomplete list of things that <emphasis>ClojureScript</emphasis> inherits and reuse from the underlying
platform:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>ClojureScript</emphasis> strings are javascript <emphasis role="strong">Strings</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>ClojureScript</emphasis> numbers are javascript <emphasis role="strong">Numbers</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>ClojureScript</emphasis> <literal>nil</literal> is a javascript <emphasis role="strong">null</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><emphasis>ClojureScript</emphasis> regular expressions are javascript <literal>RegExp</literal> instances.</simpara>
</listitem>
<listitem>
<simpara><emphasis>ClojureScript</emphasis> is not interpreted, is always compiled town to the javascript.</simpara>
</listitem>
<listitem>
<simpara><emphasis>ClojureScript</emphasis> allows easy call platform apis with the same semantics.</simpara>
</listitem>
<listitem>
<simpara><emphasis>ClojureScript</emphasis> data types internally compiles to objects in javascript.</simpara>
</listitem>
</itemizedlist>
<simpara>On top of it, <emphasis>ClojureScript</emphasis> buid own abstractions and types that are does not exists in the
platform, such as Vectors, Maps, Sets, and others that are explained in previous chapters.</simpara>
</section>
<section id="_interacting_with_platform_types">
<title>Interacting with platform types</title>
<simpara><emphasis>ClojureScript</emphasis> comes with a little set of special forms that allows interact with platform
types such as calling object methods, creating new instances and accessing to object
properties.</simpara>
<section id="_access_to_the_platform">
<title>Access to the platform</title>
<simpara><emphasis>ClojureScript</emphasis> has a special syntax for access to the all platform environment through the
<literal>js/</literal> special namespace. This is the aspect of the expression for execute the javascript&#8217;s
builtin <literal>parseInt</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(js/parseInt "222")
;; =&gt; 222</programlisting>
</section>
<section id="_creating_new_instances">
<title>Creating new instances</title>
<simpara><emphasis>ClojureScript</emphasis> has two ways to create instances:</simpara>
<formalpara>
<title>Using the <literal>new</literal> special form</title>
<para>
<programlisting language="clojure" linenumbering="unnumbered">(new js/Regex "^foo$")</programlisting>
</para>
</formalpara>
<simpara>Using the <literal>.</literal> special form</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(js/Regex. "^foo$")</programlisting>
<simpara>The last one is the recommended way to do that operation. We do not aware of real differences
between the two forms, but in the clojurescript comunity the last one is the most adopted.</simpara>
</section>
<section id="_invoke_instance_methods">
<title>Invoke instance methods</title>
<simpara>For invoke methods of some object instance, in contrary to how it used in javascript (eg:
<literal>obj.method()</literal>, the method name comes first like any other standard function in lisp languages
but with little variation: the function name starts with special form <literal>.</literal>.</simpara>
<simpara>Let see how we can call the <literal>.test()</literal> method of regexp instance:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def re (js/RegExp "^foo"))

(.test re "foobar")
;; =&gt; true</programlisting>
</section>
<section id="_access_to_object_properties">
<title>Access to object properties</title>
<simpara>Access to the object properties is really very similar to call a method, the difference is that
instead of using the <literal>.</literal> we should use the <literal>.-</literal>. Let see an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(.-multiline re)
;; =&gt; false</programlisting>
</section>
<section id="_javascrpt_objects">
<title>Javascrpt objects</title>
<simpara><emphasis>ClojureScript</emphasis> has different ways for create plain javascript objects, each one has its own
purpose. The basic one is the <literal>js-obj</literal> function. It accepts a variable length of pairs of key
values and return a javascript object:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(js-obj "foo" "bar")
;; =&gt; #js {:foo "bar"}</programlisting>
<simpara>The return value can be passed to some kind of third party library that accepts a plain
javascript objects. But you can observe the repl representation of the return value of this
function. It is exactly the other form for do the same thing.</simpara>
<simpara>Using the reader macro <literal>#js</literal> consists of prepend it to the clojure map or vector and the
result will be transformed to plain javascript:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def myobj #js {:foo "bar"})</programlisting>
<simpara>The translation of that to plain javascript is similar to this:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">var myobj = {foo: "bar"};</programlisting>
<simpara>As explained in previous section, you also can access to the plain object properties using
the <literal>.-</literal> syntax:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(.-foo myobj)
;; =&gt; "bar"</programlisting>
<simpara>And as javascript objects are mutable, you can set a new value to some property using
the <literal>set!</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(set! (.-foo myobj) "baz")</programlisting>
</section>
<section id="_conversions">
<title>Conversions</title>
<simpara>The inconvenience of previously explained forms, is that they does not make recursive
transformatios, so if you have nested objects, the nested objects do not will be converted.
For solve that use cases, <emphasis>ClojureScript</emphasis> comes with <literal>clj&#8594;js</literal> and <literal>js&#8594;clj</literal> functions
that transforms clojure collection types into javascript and in reverse order:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(clj-&gt;js {:foo {:bar "baz"}})
;; =&gt; #js {:foo #js {:bar "baz"}}</programlisting>
<simpara>In case of arrays, it there a specialized function <literal>into-array</literal> that behaves as it expected:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(into-array ["foo"])
;; =&gt; #js ["foo"]</programlisting>
</section>
<section id="_arrays">
<title>Arrays</title>
<simpara>In previous example we have seen how we can create an array from existing <emphasis>ClojureScript</emphasis>
collection. But it there other function for create arrays: <literal>make-array</literal>.</simpara>
<formalpara>
<title>Creating a preallocated array with length 10</title>
<para>
<programlisting language="clojure" linenumbering="unnumbered">(def a (make-array 10))
;; =&gt; #js [nil nil nil nil nil nil nil nil nil nil]</programlisting>
</para>
</formalpara>
<simpara>In <emphasis>ClojureScript</emphasis> arrays are also play well in sequence abstraction so you can iterate
over it or simple get the number of elements with <literal>count</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(count a)
;; =&gt; 10</programlisting>
<simpara>As arrays are platform mutable collection type, you can acces to a concrete index and set
value to on that position:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(aset a 0 2)
;; =&gt; 2</programlisting>
<simpara>Or access in a indexed way to it values:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(aget a 0)
;; =&gt; 2</programlisting>
<simpara>In javascript, the objects are also arrays, so you can use the same functions for interacting
with plain objects:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def b #js {:foo "bar"})
;; =&gt; #js {:foo "bar"}

(aget b "foo")
;; =&gt; "bar"

(aset b "baz" "bar")
;; =&gt; "bar"

b
;; =&gt; #js {:foo "bar", :baz "bar"}</programlisting>
</section>
</section>
</section>
<section id="_state_management">
<title>State management</title>
<simpara>TBD</simpara>
</section>
<section id="_truthiness">
<title>Truthiness</title>
<simpara>This is the aspect where the each language has its own semantics, the majority of languages
treats empty collections, the 0 integer and other things like this are considered false.
In <emphasis>ClojureScript</emphasis> unlike in other languages only two values are considered as false: <literal>nil</literal>
and <literal>false</literal>, Everything except them, are treated as <literal>true</literal>.</simpara>
<simpara>So, thanks to it, sets can be considered also predicates, so if them return a value so it exists
and if it return <literal>nil</literal> so the value does not exists:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def s #{1 2})

(s 1)
;; =&gt; 1

(s 3)
;; =&gt; nil</programlisting>
</section>
<section id="_a_little_overview_of_macros">
<title>A little overview of macros</title>
<simpara>TBD</simpara>
</section>
</chapter>
<chapter id="_tooling_compiler">
<title>Tooling &amp; Compiler</title>
<simpara>This chapter will cover a little introduction to existing tooling for making things easy when
developing using ClojureScript. It will cover:</simpara>
<itemizedlist>
<listitem>
<simpara>Using the repl</simpara>
</listitem>
<listitem>
<simpara>Leiningen and cljsbuild</simpara>
</listitem>
<listitem>
<simpara>Google Closure Library</simpara>
</listitem>
<listitem>
<simpara>Modules</simpara>
</listitem>
<listitem>
<simpara>Unit testing</simpara>
</listitem>
<listitem>
<simpara>Library development</simpara>
</listitem>
<listitem>
<simpara>Browser based development</simpara>
</listitem>
<listitem>
<simpara>Server based development</simpara>
</listitem>
</itemizedlist>
<simpara>Unlike the previos chapter, this chapter intends to tell different stories not mandatory that
all related to each other.</simpara>
<section id="_getting_started_with_compiler">
<title>Getting started with Compiler</title>
<simpara>The <emphasis>ClojureScript</emphasis> compiler is implemented like it brother <emphasis>Clojure</emphasis> in java, and for use it, you
should have jdk8 installed. <emphasis>ClojureScript</emphasis> itself only requires jdk7, but the standalone compiller
that we going to use in this chapter  requires jdk8.</simpara>
<simpara>Additionally, for avoid constantly have a browser for execute our compiled code, in examples of this
section we will use nodejs or iojs, so you shuld have to be installed. Nodejs is not a dependency
of <emphasis>ClojureScript</emphasis>, is just one of possible execution enviroments and it will used for execute our
examples.</simpara>
<simpara>You can test the <emphasis role="strong">iojs</emphasis> installed in your system with this command:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ iojs --version
v1.7.1</programlisting>
<simpara>The usage of the <emphasis>ClojureScript</emphasis> compiler as it will be explained in this section, is for understand
how it works behind the scenes and for use it in circumstances where you do not have o do not want
other kind of tooling.</simpara>
<simpara>Surelly that in the real world projects, you will use other more high level tools how leiningen+cljsbuld
or boot (explained in following sections).</simpara>
<section id="_download_the_jar">
<title>Download the jar</title>
<simpara>In recent versions of <emphasis>ClojureScript</emphasis>, now we have the compiler as standalone java
dependency, packaged in one unique executable jar file.</simpara>
<simpara>You can download it using wget:</simpara>
<programlisting language="bash" linenumbering="unnumbered">wget https://github.com/clojure/clojurescript/releases/download/r3211/cljs.jar</programlisting>
</section>
<section id="_first_compilation">
<title>First compilation</title>
<section id="_create_the_example_application">
<title>Create the example application</title>
<simpara>For this step we need some clojurescript code for our examples. So start creating
the directory tree structure for our "hello world" application:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mkdir -p src/myapp
touch src/myapp/core.cljs</programlisting>
<simpara>And secondly, write the following code into the previously created <literal>src/myapp/core.cljs</literal>
file:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns myapp.core
  (:require [cljs.nodejs :as nodejs]))

(nodejs/enable-util-print!)

(defn -main [&amp; args]
  (println "Hello world!"))

(set! *main-cli-fn* -main)</programlisting>
<simpara>Is very important that the declared namespace in the file match exactly the directory
structure. Is the way how <emphasis>ClojureScript</emphasis> structures its source code.</simpara>
</section>
<section id="_compile_the_example_application">
<title>Compile the example application</title>
<simpara>Now, in order to compile that source code, we need a simple build script that
instructs the <emphasis>ClojureScript</emphasis> compiler the source directory and the output file. The
<emphasis>ClojureScript</emphasis> has a lot of other options but at this momen we can ignore that.</simpara>
<simpara>Let create the <emphasis>build.clj</emphasis> file with the following content:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(require 'cljs.closure)

(cljs.closure/build "src"
 {:output-to "main.js"
  :main myapp.core
  :target :nodejs})</programlisting>
<simpara>The <literal>:output-to</literal> parameter indicates to the compiler the destination of the compiled code, in this
case to the "main.js" file. The <literal>:main</literal> propety indicates to the compiler the namespace that will
acts as the entry point of your application when it&#8217;s executed. And finally the <literal>:target</literal> property
indicates the platform when you want execute the compiled code. In this case we are going to use
<emphasis role="strong">iojs</emphasis> (formerly nodejs). If you ommit this parameter the source will be compiled for run in the
browser environment.</simpara>
<simpara>For run the compilation, just execute the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">java -cp cljs.jar:src clojure.main build.clj</programlisting>
<simpara>And when it finishes, execute the compiled file using <emphasis role="strong">iojs</emphasis>:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ iojs main.js
"Hello world"</programlisting>
</section>
</section>
</section>
<section id="_working_with_the_repl">
<title>Working with the REPL</title>
<simpara>TBD</simpara>
</section>
<section id="_build_dependency_management_tools">
<title>Build &amp; Dependency management tools</title>
<section id="_getting_started_with_leiningen">
<title>Getting started with leiningen.</title>
<simpara>TBD</simpara>
</section>
<section id="_getting_started_with_boot">
<title>Getting started with boot.</title>
<simpara>TBD</simpara>
</section>
</section>
<section id="_the_closure_library">
<title>The Closure Library</title>
<simpara>TBD</simpara>
</section>
<section id="_browser_based_development">
<title>Browser based development</title>
<simpara>TBD</simpara>
<section id="_using_third_party_javascript_libraryes">
<title>Using third party javascript libraryes</title>
<simpara>TBD</simpara>
</section>
<section id="_modularizing_your_code">
<title>Modularizing your code</title>
<simpara>TBD</simpara>
</section>
</section>
<section id="_developing_a_library">
<title>Developing a library</title>
<simpara>TBD</simpara>
</section>
<section id="_unit_testing">
<title>Unit testing</title>
<simpara>TBD</simpara>
</section>
</chapter>
<chapter id="_mixed_bag">
<title>Mixed Bag</title>
<simpara>This chapter will cover miscelaneous topics that are not classified in the previous ones. This is a
"catchall" section and will touch a bunch of heterogeneus topics like:</simpara>
<itemizedlist>
<listitem>
<simpara>Async primitives using <emphasis>core.async</emphasis> library.</simpara>
</listitem>
<listitem>
<simpara>Working with promises.</simpara>
</listitem>
<listitem>
<simpara>Error handling using <emphasis>cats</emphasis> library.</simpara>
</listitem>
<listitem>
<simpara>Pattern matching with <emphasis>core.match</emphasis> library.</simpara>
</listitem>
<listitem>
<simpara>Web development using Om library.</simpara>
</listitem>
<listitem>
<simpara>Share code betwen clojure and clojurescript.</simpara>
</listitem>
</itemizedlist>
<section id="_async_primitives_using_core_async">
<title>Async primitives using core.async.</title>
<simpara>TBD</simpara>
</section>
<section id="_working_with_promises">
<title>Working with promises.</title>
<simpara>TBD</simpara>
</section>
<section id="_error_handling_using_monads_and_cats">
<title>Error handling using monads and Cats.</title>
<simpara>TBD</simpara>
</section>
<section id="_pattern_matching_using_core_match">
<title>Pattern matching using core.match.</title>
<simpara>TBD</simpara>
</section>
<section id="_web_development_with_om_and_react">
<title>Web development with Om and React.</title>
<simpara>TBD</simpara>
</section>
<section id="_writing_libraries_that_shares_code_betwen_clojure_and_clojurescript">
<title>Writing libraries that shares code betwen Clojure and ClojureScript.</title>
<simpara>TBD</simpara>
</section>
</chapter>
</book>