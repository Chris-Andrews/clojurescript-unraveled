<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc maxdepth="3"?>
<?asciidoc-numbered?>
<book lang="en">
<bookinfo>
<title>ClojureScript Unraveled</title>
<date>2015-06-02</date>
<authorgroup>
<author>
<firstname>Andrey</firstname>
<surname>Antukh</surname>
<email>niwi@niwi.be</email>
</author>
<author>
<firstname>Alejandro</firstname>
<surname>Gomez</surname>
<email>alejandro@dialelo.com</email>
</author>
</authorgroup>
<revhistory>
<revision>
<revnumber>1</revnumber>
<date>2015-06-02</date>
<authorinitials>AA</authorinitials>
</revision>
</revhistory>
</bookinfo>
<chapter id="about-this-book">
<title>About this book</title>
<simpara>This book covers the ClojureScript programming language, a detailed guide of its tooling for
development and a series of articles about topics that are applicable in day-to-day programming
in ClojureScript.</simpara>
<simpara>It is not an introductory book to programming in that it assumes the reader has experience programming in at least
one language. However, it doesn&#8217;t assume experience with ClojureScript or functional programming. We&#8217;ll try to
include links to reference material when talking about the theoretical programming language aspects of ClojureScript
that may be not be familiar to everybody.</simpara>
<simpara>Also, since the ClojureScript documentation is good but disperse, we wanted to write a compendium of reference
information and extensive examples to serve as a ClojureScript primer as well as a series of practical how-to&#8217;s.
This document will evolve with the ClojureScript language, both as a reference of the language features and a
sort of cookbook with practical programming recipes.</simpara>
<simpara>You&#8217;ll get the most ouf this book if you:</simpara>
<itemizedlist>
<listitem>
<simpara>are curious about ClojureScript or functional programming and you have some programming experience;</simpara>
</listitem>
<listitem>
<simpara>write JavaScript or any other language that compiles to it and want to know what ClojureScript has to offer;</simpara>
</listitem>
<listitem>
<simpara>you already know some Clojure and want to learn how ClojureScript differs from it, plus practical topics like
how to target both languages with the same code base.</simpara>
</listitem>
</itemizedlist>
<simpara>Don&#8217;t be turned off if you don&#8217;t see yourself in neither of the above groups, we encourage you to give this book
a try and give us feedback on how we can make it more accesible. Our goal is to make ClojureScript more friendly
to newcomers and spread the ideas about programming that Clojure has helped popularize, as we see a lot of
value in them.</simpara>
</chapter>
<chapter id="introduction">
<title>Introduction</title>
<simpara>This chapter is an introduction to the Clojure ecosystem, and intends to explain
the philosophy behind it.</simpara>
<section id="first-contact">
<title>First contact</title>
<simpara><emphasis>ClojureScript</emphasis> is an implementation of the Clojure programming language that
targets JavaScript. Because of this it can run in many different execution
environments including web browsers, Node.js, io.js, and Nashhorn.</simpara>
<simpara>Unlike other languages that intend to <emphasis>compile</emphasis> to JavaScript (like TypeScript,
FunScript or CoffeeScript), ClojureScript is designed to use JavaScript like bytecode. It embraces
functional programming, and has very safe and consistent defaults.</simpara>
<simpara>Another big difference (and in my opinion a big advantage) over other languages is that Clojure
is designed to be a guest. It is a language without its own virtual machine that
can be easy adapted to differences between its execution environments.</simpara>
<simpara>TBD</simpara>
</section>
<section id="the-pillars-of-the-language">
<title>The pillars of the language</title>
<simpara>TBD</simpara>
</section>
<section id="why-host-on-javascript">
<title>Why host on JavaScript?</title>
<simpara>TBD</simpara>
</section>
</chapter>
<chapter id="the-language">
<title>The language.</title>
<simpara>This chapter will be a little introduction to ClojureScript without assumptions about previous
knowledge of the Clojure language, providing a quick tour over all the things you will need to know
in order to understand the rest of this book.</simpara>
<section id="first-steps-with-lisp-syntax">
<title>First steps with Lisp syntax</title>
<simpara>Invented by John McCarthy in 1958, Lisp is one of the oldest programming languages that is still
around. It has evolved into many derivatives called dialects, and ClojureScript is
one of them. It&#8217;s a programming language written in its own data structures, originally lists enclosed in
parentheses, but Clojure(Script) has evolved the Lisp syntax with more data structures, making
it more pleasant to write and read.</simpara>
<simpara>A list with a function in the first position is used for calling a function in ClojureScript:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(+ 1 2 3)
;; =&gt; 6</programlisting>
<simpara>In the example above, we&#8217;re applying the addition function <literal>+</literal> to the arguments 1, 2 and 3. ClojureScript
allows many unusual characters like <literal>?</literal> or <literal>-</literal> in symbol names, which makes it easier to read:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(zero? 0)
;; =&gt; true</programlisting>
<simpara>For distinguishing function calls and lists, we can quote lists to keep them from being evaluated. The quoted
lists will be treated as data instead of as a function call:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">'(+ 1 2 3)
;; =&gt; (+ 1 2 3)</programlisting>
<simpara>ClojureScript uses more than lists for its syntax. The full details will be covered later, but here is an
example of the usage of a vector (enclosed in brackets) for defining local bindings:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [x 1
      y 2
      z 3]
  (+ x y z))
;; =&gt; 6</programlisting>
<simpara>This is practically all the syntax we need to know for using not only ClojureScript, but any Lisp. Being
written in its own data structures (often referred to as <emphasis>homoiconicity</emphasis>) is a great property since the
syntax is uniform and simple; also, code generation via macros is easier than in any other language, giving
us plenty of power to extend the language to suit our needs.</simpara>
</section>
<section id="the-base-data-types">
<title>The base data types</title>
<simpara>The ClojureScript language has a rich set of data types like most programming languages. It provides
scalar datatypes that will be very familiar to you, such as numbers, strings, and floats. Beyond these, it also
provides a great number of others that might be less familiar, such as symbols, keywords, regex (regular expressions),
vars, atoms, volatiles&#8230;&#8203;</simpara>
<simpara><emphasis>ClojureScript</emphasis> embraces the host language, and where possible it uses the host&#8217;s provided types. For example:
numbers and strings are used as is, and they behave in same way as in JavaScript.</simpara>
<section id="numbers">
<title>Numbers</title>
<simpara>In <emphasis>ClojureScript</emphasis>,  numbers include both integers and floating points. Keeping in mind that
<emphasis>ClojureScript</emphasis> is a guest language that compiles to JavaScript, integers are actually JavaScript&#8217;s native
floating points under the hood.</simpara>
<simpara>As in any other language, numbers in <emphasis>ClojureScript</emphasis> are represented in following ways:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">23
+23
-100
1.7
-2
33e8
12e-14
3.2e-4</programlisting>
</section>
<section id="keywords">
<title>Keywords</title>
<simpara>Keywords in <emphasis>ClojureScript</emphasis> are objects that always evaluate to themselves. They are usually
used in <link linkend="maps-section">map data structures</link> to efficiently represent the keys.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">:foobar
:2
:?
:foo/bar</programlisting>
<simpara>As you can see, the keywords are all prefixed with <literal>:</literal>, but this character is only part
of the literal syntax and is not part of the name of the object.</simpara>
<simpara>You can also create a keyword by calling the <literal>keyword</literal> function. Don&#8217;t worry if you don&#8217;t understand
or are unclear about anything in the following example; <link linkend="function-section">functions</link> are discussed in a later section.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(keyword "foo")
;; =&gt; :foo</programlisting>
</section>
<section id="symbols">
<title>Symbols</title>
<simpara>Symbols in <emphasis>ClojureScript</emphasis> are very, very similar to <emphasis role="strong">Keywords</emphasis> (which you now know about). But
instead of evaluating to themselves, symbols are evaluated to something that they refer to, which
can be functions, variables, etc.</simpara>
<simpara>Symbols are represented with something that does not start with a number:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">sample-symbol
othersymbol
f1</programlisting>
<simpara>Don&#8217;t worry if you don&#8217;t understand right away; symbols are used in almost
all of our examples, which will give you the opportunity to learn more as we go on.</simpara>
</section>
<section id="strings">
<title>Strings</title>
<simpara>There is almost nothing new we can explain about strings that you don&#8217;t already know. In <emphasis>ClojureScript</emphasis>, they
 work the same as in any other language. One point of interest, however, is that they are immutable.</simpara>
<simpara>In this case they are the same as in JavaScript:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">"An example of a string"</programlisting>
<simpara>One peculiar aspect of strings in <emphasis>ClojureScript</emphasis> is due to the language&#8217;s Lisp syntax: single and multiline strings
have the same syntax:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">"This is a multiline
      string in ClojureScript."</programlisting>
</section>
<section id="characters">
<title>Characters</title>
<simpara><emphasis>ClojureScript</emphasis> also lets you write single characters using Clojure&#8217;s character literal syntax.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">\a        ; The lowercase a character
\newline  ; The new line character</programlisting>
<simpara>Since the host language doesn&#8217;t contain character literals, <emphasis>ClojureScript</emphasis> characters are transformed
behind the scenes into single character JavaScript strings.</simpara>
</section>
<section id="collections">
<title>Collections</title>
<simpara>Another big step in explaining a language is to explain its collections and collection
abstractions. <emphasis>ClojureScript</emphasis> is not an exception to this rule.</simpara>
<simpara><emphasis>ClojureScript</emphasis> comes with many types of different collections. The main difference between <emphasis>ClojureScript</emphasis>
collections and collections in other languages is that they are persistent and immutable.</simpara>
<simpara>Before moving on to all of these (possibly) unknown concepts, we&#8217;ll present a high level overview
of existing collection types in <emphasis>ClojureScript</emphasis>.</simpara>
<section id="lists">
<title>Lists</title>
<simpara>This is a classic collection type in languages based on Lisp. Lists are the
simplest type of collection in <emphasis>ClojureScript</emphasis>. Lists can contain items of any type, including
other collections.</simpara>
<simpara>Lists in <emphasis>ClojureScript</emphasis> are represented by items enclosed between parentheses:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">'(1 2 3 4 5)
'(:foo :bar 2)</programlisting>
<simpara>As you can see, all list examples are prefixed with the <literal>'</literal> char. This is because lists in Lisp-like
languages are often used to express things like function or macro calls. In that case,
the first item should be a symbol that will evaluate to something callable, and the rest of the list
elements will be function arguments. However, in the preceding examples, we don&#8217;t want the first item as a symbol;
we just want a list of items.  The following example shows the difference between a list without and with the preceding
single quote mark:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(inc 1)
;; =&gt; 2

'(inc 1)
;; =&gt; (inc 1)</programlisting>
<simpara>As you see, if you  evaluate <literal>(inc 1)</literal> without prefixing it with <literal>'</literal>, it will resolve
the <literal>inc</literal> symbol to the <emphasis role="strong">inc</emphasis> function and will execute it with <literal>1</literal> as first argument, returning the value <literal>2</literal>.</simpara>
<simpara>You can also explicitly create a list with the <literal>list</literal> function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(list 1 2 3 4 5)
;; =&gt; (1 2 3 4 5)

(list :foo :bar 2)
;; =&gt; (:foo :bar 2)</programlisting>
<simpara>Lists have the pecularity that they are very efficient if you access them sequentially or
access their first elements, but a list is not a very good option if you need random (index) access to its
elements.</simpara>
</section>
<section id="vectors">
<title>Vectors</title>
<simpara>Like lists, <emphasis role="strong">vectors</emphasis>  store a series of values, but in this case with very efficient index access
to their elements, as opposed to lists, which are evaluated in order. Don&#8217;t worry; in
the following chapters we&#8217;ll go in depth with details, but at this moment, this simple explanation is
more than enough.</simpara>
<simpara>Vectors use square brackets for the literal syntax; let&#8217;s see some examples:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">[:foo :bar]
[3 4 5 nil]</programlisting>
<simpara>Like lists, vectors can contain objects of any type, as you can observe in the preceding example.</simpara>
<simpara>You can also explicitly create a vector with the <literal>vector</literal> function, but this is not commonly used in ClojureScript programs:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(vector 1 2 3)
;; =&gt; [1 2 3]

(vector "blah" 3.5 nil)
;; =&gt; ["blah" 3.5 nil]</programlisting>
</section>
<section id="maps-section">
<title>Maps</title>
<simpara>Maps are a collection abstraction that allows you to store key/value pairs. In other
languages this type of structure is commonly known as a hash-map or dict (dictionary). Map literals
in <emphasis>ClojureScript</emphasis> are written with the pairs between curly braces.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">{:foo "bar", :baz 2}
{:alphabet [:a :b :c]}</programlisting>
<note>
<simpara>Commas are frequently used to separate a key-value pair but are completely optional. In
<emphasis>ClojureScript</emphasis> syntax, commas are treated like spaces.</simpara>
</note>
<simpara>Like vectors, every item in a map literal is evaluated before the result is stored in a map, but
the order of evaluation is not guaranteed.</simpara>
</section>
<section id="sets">
<title>Sets</title>
<simpara>And finally, <emphasis role="strong">Sets</emphasis>.</simpara>
<simpara>Sets store zero or more unique items of any type and are unordered. They,
like maps, use curly braces for their literal syntax, with the difference being that they use a <literal>#</literal> as leading
character:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">#{1 2 3 :foo :bar}</programlisting>
<simpara>In subsequent chapters we&#8217;ll go in depth about sets and the other collection types you&#8217;ve seen in this
chapter.</simpara>
</section>
</section>
</section>
<section id="vars">
<title>Vars</title>
<simpara><emphasis>ClojureScript</emphasis> is a mostly functional language and focused on immutability. Because of that, it does
not have the concept of variables as you know them in most other programming languages. The closest analogy to
variables are the variables you define in algebra; when you say <literal>x = 6</literal> in mathematics, you are saying that you
want the symbol <literal>x</literal> to stand for the number six.</simpara>
<simpara>In <emphasis>ClojureScript</emphasis>, vars are represented by symbols and store a single value together with metadata.</simpara>
<simpara>You can define a var using the <literal>def</literal> special form:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def x 22)
(def y [1 2 3])</programlisting>
<simpara>Vars are always top level in the namespace (<link linkend="namespace-section">which we will explain later</link>). If you use <literal>def</literal> in a function call,
the var will be defined at the namespace level, but we do not recommend this - instead, you should use <literal>let</literal>
to define variables within a function.</simpara>
</section>
<section id="function-section">
<title>Functions</title>
<section id="the-first-contact">
<title>The first contact</title>
<simpara>It&#8217;s time to make things happen. <emphasis>ClojureScript</emphasis> has what are known as first class functions. They behave
like any other type; you can pass them as parameters and you can return them as values, always respecting
the lexical scope. <emphasis>ClojureScript</emphasis> also has some features of dynamic scoping, but this will be discussed
in another section.</simpara>
<simpara>If you want know more about scopes, this <ulink url="http://en.wikipedia.org/wiki/Scope_(computer_science)">wikipedia article</ulink>
is very extensive and explains different types of scoping.</simpara>
<simpara>As <emphasis>ClojureScript</emphasis> is a Lisp dialect, it uses the prefix notation for calling a function:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(inc 1)
;; =&gt; 2</programlisting>
<simpara>In the example above, <literal>inc</literal> is a function and is part of the <emphasis>ClojureScript</emphasis> runtime, and <literal>1</literal> is the first
argument for the <literal>inc</literal> function.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(+ 1 2 3)
;; =&gt; 6</programlisting>
<simpara>The <literal>+</literal> symbol represents an <literal>add</literal> function. It allows multiple parameters, whereas in ALGOL-type languages,
<literal>+</literal> is an operator and only allows two parameters.</simpara>
<simpara>The prefix notation has huge advantages, some of them not always obvious. <emphasis>ClojureScript</emphasis> does not
make a distinction between a function and operator; everything is a function. The immediate advantage
is that the prefix notation allows an arbitrary number of arguments per "operator". Also, it completely
eliminates the problem of operator precedence.</simpara>
</section>
<section id="defining-your-own-functions">
<title>Defining your own functions</title>
<simpara>You can define an un-named (anonymous) function with the <literal>fn</literal> special form. This is one type of function definition;
in the following example, the function takes two parameters and returns their average.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(fn [param1 param2]
  (/ (+ param1 param2) 2.0)</programlisting>
<simpara>You can define a function and call it at same time (in a single expression):</simpara>
<programlisting language="clojure" linenumbering="unnumbered">((fn [x] (* x x)) 5)
;; =&gt; 25</programlisting>
<simpara>Let&#8217;s start creating named functions. But what does a <emphasis>named function</emphasis> really mean? It is very simple;
in <emphasis>ClojureScript</emphasis>, functions are first-class and behave like any other value, so naming a function
is done by simply binding the function to a symbol:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def square (fn [x] (* x x)))

(square 12)
;; =&gt; 144</programlisting>
<simpara><emphasis>ClojureScript</emphasis> also offers the <literal>defn</literal> macro as a little syntactic sugar for making function definition
more idiomatic:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn square
  "Return the square of a given number."
  [x]
  (* x x))</programlisting>
<simpara>The string that comes between the function name and the parameter vector is called a
<emphasis>docstring</emphasis> (documentation string); programs that automatically create web documentation
from your source files will use these docstrings.</simpara>
</section>
<section id="function-with-multiple-arities">
<title>Function with multiple arities</title>
<simpara><emphasis>ClojureScript</emphasis> also comes with the ability to define functions with arbitrary number of
arguments. (The term <emphasis>arity</emphasis> means the number of arguments that a function takes.) The
syntax is almost the same as for defining an ordinary function, with the difference that
it has more than one body.</simpara>
<simpara>Let&#8217;s see an example, which will surely explain it much better:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn myinc
  "Self defined version of parameterized `inc`."
  ([x] (myinc x 1))
  ([x increment]
   (+ x increment)))</programlisting>
<simpara>This line: <literal>([x] (myinc x 1)</literal> says that if there is only one argument, call the function
<literal>myinc</literal> with that argument and the number <literal>1</literal> as the second argument. The other function body:
<literal>([x increment] (+ x increment))</literal> says that if there are two arguments, return the result of
adding them.</simpara>
<simpara>Here are some examples using the previously defined multi-arity function. Observe that
if you call a function with wrong number of arguments, the compiler will emit an error message.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(myinc 1)
;; =&gt; 1

(myinc 1 3)
;; =&gt; 4

(myinc 1 3 3)
;; Compiler error</programlisting>
<note>
<simpara>Explaining the concept of "arity" is out of the scope of this book, however you can read about that in this
<ulink url="http://en.wikipedia.org/wiki/Arity">wikipedia article</ulink>.</simpara>
</note>
</section>
<section id="variadic-functions">
<title>Variadic functions</title>
<simpara>Another way to accept multiple parameters is defining variadic functions. Variadic functions
are functions that will be able to accept an arbitrary number of arguments:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn my-variadic-set
  [&amp; params]
  (set params))

(my-variadic-set 1 2 3 1)
;; =&gt; #{1 2 3}</programlisting>
<simpara>The way to denote a variadic function is using the <literal>&amp;</literal> symbol prefix on its arguments vector.</simpara>
</section>
<section id="short-syntax-for-anonymous-functions">
<title>Short syntax for anonymous functions</title>
<simpara><emphasis>ClojureScript</emphasis> provides a shorter syntax for defining anonymous functions using
the <literal>#()</literal> reader macro (usually leads to one liners). Reader macros are "special" expressions that will be
transformed to the appropriate language form at compile time; in this case, to some expression
that uses <literal>fn</literal> special form.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def my-set #(set (list %1 %2)))

(my-set "x" "y")
;; =&gt; #{"x" "y"}</programlisting>
<simpara>The preceding definition is shorthand for:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def my-set-longer (fn [a b] #(set (list a b))))</programlisting>
<simpara>The <literal>%1</literal>, <literal>%2</literal>, <literal>%N</literal> are simple markers for parameter positions that are implicitly declared when
the reader macro will be interpreted and converted to a <literal>fn</literal> expression.</simpara>
<simpara>Also, if a function only accepts one argument, you can omit the number after <literal>%</literal> symbol; the
function <literal>#(set (list %1))</literal> can be written <literal>#(set (list %))</literal>.</simpara>
<simpara>Additionally, this syntax also supports the variadic form with the`%&amp;` symbol:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def my-variadic-set #(set %&amp;))

(my-variadic-set 1 2 2)
;; =&gt; #{1 2}</programlisting>
</section>
</section>
<section id="flow-control">
<title>Flow control</title>
<simpara><emphasis>ClojureScript</emphasis> has a very different approach for flow control than languages like JavaScript, C, etc.</simpara>
<section id="branching-with-literal-if-literal">
<title>Branching with <literal>if</literal></title>
<simpara>Let start with a basic one: <literal>if</literal>. In <emphasis>ClojureScript</emphasis> the <literal>if</literal> is an expression and not a
statement, and it has three parameter: the first one is the condition expression, the second one
is an expression that will be evaluated if the condition expression evaluates to logical true,
and the third expression will be evaluated otherwise.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn discount
  "You get 5% discount for ordering 100 or more items"
  [quantity]
  (if (&gt;= quantity 100)
    0.05
    0))

(discount 30)
;; =&gt; 0

(discount 130)
;; =&gt; 0.05</programlisting>
<simpara>The block expression <literal>do</literal> can be used to have multiple expressions in an <literal>if</literal> branch.
<link linkend="block-section"><literal>do</literal> is explained in the next section</link>.</simpara>
</section>
<section id="branching-with-literal-cond-literal">
<title>Branching with <literal>cond</literal></title>
<simpara>Sometimes, the <literal>if</literal> expression can be slightly limited because it does not have the "else if" part
to add more than one condition. The <literal>cond</literal> comes to the rescue.</simpara>
<simpara>With the <literal>cond</literal> expression, you can define multiple conditions:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn mypos?
  [x]
  (cond
    (&gt; x 0) "positive"
    (&lt; x 0) "negative"
    :else "zero"))

(mypos? 0)
;; =&gt; "zero"

(mypos? -2)
;; =&gt; "negative"</programlisting>
<simpara>Also, <literal>cond</literal> has another form, called <literal>condp</literal>, that works very similarly to the simple <literal>cond</literal>
but looks cleaner when the condition (also called a predicate) is the same for all conditions:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn translate-lang-code
  [code]
  (condp = (keyword code)
    :es "Spanish"
    :en "English"
    "Unknown"))

(translate-lang-code "en")
;; =&gt; "English"

(translate-lang-code "fr")
;; =&gt; "Unknown"</programlisting>
<simpara>The line <literal>condp = (keyword code)</literal> means that, in each of the following lines, <emphasis>ClojureScript</emphasis>
will apply the <literal>=</literal> function to the given keyword and the <literal>code</literal> argument.</simpara>
</section>
<section id="branching-with-literal-case-literal">
<title>Branching with <literal>case</literal></title>
<simpara>The <literal>case</literal> branching expression has very similar use case as our previous example with
<literal>condp</literal>. The main difference is that <literal>case</literal> always uses the <literal>=</literal> predicate/function, and its
branching values are evaluated at compile time. This results in a more performant form
than <literal>cond</literal> or <literal>condp</literal> but has the disadvantage that the condition value must be
a static value.</simpara>
<simpara>Here is the same example as previous one, but using <literal>case</literal>:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn translate-lang-code
  [code]
  (case code
    "es" "Spanish"
    "es" "English"
    "Unknown"))

(translate-lang-code "en")
;; =&gt; "English"

(translate-lang-code "fr")
;; =&gt; "Unknown"</programlisting>
</section>
</section>
<section id="locals-blocks-and-loops">
<title>Locals, Blocks and Loops</title>
<section id="locals">
<title>Locals</title>
<simpara><emphasis>ClojureScript</emphasis> does not has the concept of variables as in ALGOL-like languages, but it does
have locals. Locals, as per usual, are immutable, and if you try mutate them, the compiler
will throw an error.</simpara>
<simpara>The locals are defined with the <literal>let</literal> expression. The expression starts with a vector as first parameter
followed by an arbitrary number of expressions. The first parameter (the vector) should contain an arbitrary
number of pairs that give a <emphasis>binding form</emphasis> (usually a symbol) followed by an expression whose value will
be bound to this new local for the remainder of the let expression.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(let [x (inc 1)
      y (+ x 1)]
  (println "Simple message from the body of a let")
  (* x y))
;; Simple message from the body of a let
;; =&gt; 6</programlisting>
<simpara>In the preceding example, the symbol <literal>x</literal> is bound to the value <literal>(inc 1)</literal>, which comes out to 2,
and the symbol <literal>y</literal> is bound to the sum of <literal>x</literal> and 1, which comes out to 3. Given those bindings, the
expressions <literal>(println "Simple message from the body of a let")</literal> and <literal>(* x y)</literal> are evaluated.</simpara>
<simpara><anchor id="block-section" xreflabel="[block-section]"/>
==== Blocks</simpara>
<simpara>In JavaScript, braces <literal>{</literal> and <literal>}</literal> delimit a block of code that “belongs together.” Blocks in
<emphasis>ClojureScript</emphasis> are created using the <literal>do</literal> expression and are usually used for side effects, like
printing something to the console or writing a log in a logger.</simpara>
<simpara>A side effect is something that is not necessary for the return value.</simpara>
<simpara>The <literal>do</literal> expression accepts as its parameter an arbitrary number of other expressions, but it returns
the return value only from the last one:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(do
   (println "hello world")
   (println "hola mundo")
   (* 3 5) ;; this value will not be returned; it is thrown away
   (+ 1 2))

;; hello world
;; hola mundo
;; =&gt; 3</programlisting>
<simpara>The body of the <literal>let</literal> expression, explained in previous section, is very similar to the
<literal>do</literal> expression, in that it allows multiple expressions. In fact, the <literal>let</literal> has an implicit <literal>do</literal>.</simpara>
</section>
<section id="loops">
<title>Loops</title>
<simpara>The functional approach of <emphasis>ClojureScript</emphasis> means that it does not have standard,
well known statement-based loops such as <literal>for</literal> in JavaScript. The loops in <emphasis>ClojureScript</emphasis> are handled using recursion.
Recursion sometimes requires additional thinking about how to model your problem in
a slightly different way than imperative languages.</simpara>
<simpara>Also, many of the common patterns for which <literal>for</literal> is used in other languages are achieved
through higher-order functions - functions that accept other functions as parameters.</simpara>
<section id="looping-with-loop-recur">
<title>Looping with loop/recur</title>
<simpara>Let&#8217;s take a look at how to express loops using recursion with the <literal>loop</literal> and <literal>recur</literal> forms.
<literal>loop</literal> defines a possibly empty list of bindings (notice the symmetry with <literal>let</literal>) and <literal>recur</literal>
jumps execution back to the looping point with new values for those bindings.</simpara>
<simpara>Let&#8217;s see an example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(loop [x 0]
   (println "Looping with " x)
   (if (= x 2)
     (println "Done looping!")
     (recur (inc x))))
;; Looping with 0
;; Looping with 1
;; Looping with 2
;; Done looping!
;; =&gt; nil</programlisting>
<simpara>In the above snippet, we bind the name <literal>x</literal> to the value <literal>0</literal> and execute the body. Since the
condition is not met the first time it&#8217;s run we <literal>recur</literal>, incrementing the binding value with
the <literal>inc</literal> function. We do this once more until the condition is met and, since there aren&#8217;t
more <literal>recur</literal> calls, exit the loop.</simpara>
<simpara>Note that <literal>loop</literal> isn&#8217;t the only point we can <literal>recur</literal> to; using <literal>recur</literal> inside a function
executes the body of the function recursively with the new bindings:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn recursive-function [x]
   (println "Looping with" x)
   (if (= x 2)
     (println "Done looping!")
     (recur (inc x))))

(recursive-function 0)
;; Looping with 0
;; Looping with 1
;; Looping with 2
;; Done looping!
;; =&gt; nil</programlisting>
</section>
<section id="replacing-for-loops-with-higher-order-functions">
<title>Replacing for loops with higher-order functions</title>
<simpara>In imperative programming languages it is common to use <literal>for</literal> loops to iterate over data and
transform it, usually the intent being one of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Transform every value in the iterable yielding another iterable</simpara>
</listitem>
<listitem>
<simpara>Filter the elements of the iterable by certain criteria</simpara>
</listitem>
<listitem>
<simpara>Convert the iterable to a value where each iteration depends on the result from the previous one</simpara>
</listitem>
<listitem>
<simpara>Run a computation for every value in the iterable</simpara>
</listitem>
</itemizedlist>
<simpara>The above actions are encoded in higher-order functions and syntactic constructs in ClojureScript;
let&#8217;s see an example of the first three.</simpara>
<simpara>For transforming every value in an iterable data structure we use the <literal>map</literal> function, which takes a
function and a sequence and applies the function to every element:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(map inc [0 1 2])
;; =&gt; (1 2 3)</programlisting>
<simpara>The first paramater for <literal>map</literal> can be <emphasis>any</emphasis> function that takes one argument and returns a value.
For example, if you had a graphing application and you wanted to graph the equation
<literal>y&#160;=&#160;3x&#160;+&#x160;5</literal> for a set of <emphasis>x</emphasis> values, you could get the <emphasis>y</emphasis> values like this:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn y-value [x] (+ (* 3 x) 5))

(map y-value [1 2 3 4 5])
;; =&gt; (8 11 14 17 20)</programlisting>
<simpara>If your function is short, you can use an anonymous function instead, either the normal or short syntax:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(map (fn [x] (+ (* 3 x) 5)) [1 2 3 4 5])
;; =&gt; (8 11 14 17 20)
(map #(+ (* 3 %1) 5) [1 2 3 4 5])
;; =&gt; (8 11 14 17 20)</programlisting>
<simpara>For filtering the values of a data structure we use the <literal>filter</literal> function, which takes a predicate
and a sequence and gives a new sequence with only the elements that returned <literal>true</literal> for the given
predicate:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(filter odd? [1 2 3 4])
;; =&gt; (1 3)</programlisting>
<simpara>Again, you can use any function that returns <literal>true</literal> or <literal>false</literal> as the first argument to <literal>filter</literal>.
Here is an example that keeps only words less than five characters long. (The <literal>count</literal> function
returns the length of its argument.)</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(filter (fn [word] (&lt; (count word) 5)) ["ant" "baboon" "crab" "duck" "echidna" "fox"])
;; =&gt; ("ant" "crab" "duck" "fox")

Converting an iterable to a single value, accumulating the intermediate result at every step of the iteration
can be achieved with `reduce`, which takes a function for accumulating values, an optional initial value
and a collection:

[source, clojure]</programlisting>
<simpara>(reduce + 0 [1 2 3 4])
;; &#8658; 10</simpara>
<screen>Yet again, you can provide your own function as the first argument to `reduce`, but your function must have
_two_ parameters. The first one is the "accumulated value" and the second parameter is the collection item
being processed. The function returns a value that becomes the accumulator for the next item in the list.
For example, here is how you would find the sum of squares of a set of numbers (this is
an important calculation in statistics). Using a separate function:

[source, clojure]</screen>
<simpara>(defn sum-squares [accumulator item]
  (+ accumulator (* item item)))</simpara>
<simpara>(reduce sum-squares 0 [3 4 5])
;; &#8658; 50</simpara>
<screen>...and with an anonymous function:

[source, clojure]</screen>
<simpara>(reduce (fn [acc item] (+ acc (* item item))) 0 [3 4 5])
;; &#8658; 50</simpara>
<screen>Here is a `reduce` that finds the total number of characters in a set of words:

[source, clojure]</screen>
<simpara>(reduce (fn [acc word] (+ acc (count word))) 0 ["ant" "bee" "crab" "duck"])
;; &#8658; 14</simpara>
<screen>We have not used the short syntax here, because although it requires less typing,
it can be less readable, and when you are starting with a new language,
it's important to be able to read what you wrote! If you are comfortable with the
short syntax, feel free to use it.

Remember to choose your starting value for the accumulator carefully. If you
wanted to use `reduce` to find the product of a series of numbers, you would have to start
with one rather than zero, otherwise all the numbers would be multiplied by zero!

[source, clojure]</screen>
<variablelist>
<varlistentry>
<term></term>
<listitem>
<simpara>wrong starting value
(reduce * 0 [3 4 5])</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term></term>
<listitem>
<simpara>&#8658; 0</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term></term>
<listitem>
<simpara>correct starting accumulator
(reduce * 1 [3 4 5])</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term></term>
<listitem>
<simpara>&#8658; 60</simpara>
</listitem>
</varlistentry>
</variablelist>
<screen>===== `for` sequence comprehensions

In ClojureScript the `for` construct isn't used for iteration but for generating sequences, an operation
also known as "sequence comprehension". It offers a small domain specific language for declaratively
building sequences.
////
That previous sentence will totally lose a beginning programmer.
////

`for` takes a vector of bindings and a expression and generates a sequence of the result of evaluating the
expression. Let's take a look at an example:

[source, clojure]</screen>
<simpara>(for [x [1 2 3]]
  [x (* x x)])
;; &#8658; ([1 1] [2 4] [3 9])</simpara>
<screen>In this example, `x` is bound to each of the items in the vector `[1 2 3]` in turn, and returns a new
sequence of two-item vectors with the original item squared.

`for` supports multiple bindings, which will cause the collections to be iterated in a nested fashion, much
like nesting `for` loops in imperative languages. The innermost binding iterates “fastest.”

[source, clojure]</screen>
<simpara>(for [x [1 2 3]
      y [4 5]]
  [x y])</simpara>
<variablelist>
<varlistentry>
<term></term>
<listitem>
<simpara>&#8658; ([1 4] [1 5] [2 4] [2 5] [3 4] [3 5])</simpara>
</listitem>
</varlistentry>
</variablelist>
<screen>We can also follow the bindings with three modifiers: `:let` for creating local bindings, `:while` for
breaking out of the sequence generation, and `:when` for filtering out values.

Here's an example of local bindings using the `:let` modifier; note that the bindings defined with it
will be available in the expression:

[source, clojure]</screen>
<simpara>(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]]
  z)
;; &#8658; (5 6 6 7 7 8)</simpara>
<screen>We can use the `:while` modifier for expressing a condition that, when it is no longer met, will stop
the sequence generation. Here's an example:

[source, clojure]</screen>
<simpara>(for [x [1 2 3]
      y [4 5]
      :while (= y 4)]
  [x y])</simpara>
<variablelist>
<varlistentry>
<term></term>
<listitem>
<simpara>&#8658; ([1 4] [2 4] [3 4])</simpara>
</listitem>
</varlistentry>
</variablelist>
<screen>For filtering out generated values, use the `:when` modifier as in the following example:

[source, clojure]</screen>
<simpara>(for [x [1 2 3]
      y [4 5]
      :when (= (+ x y) 6)]
  [x y])</simpara>
<variablelist>
<varlistentry>
<term></term>
<listitem>
<simpara>&#8658; ([1 5] [2 4])</simpara>
</listitem>
</varlistentry>
</variablelist>
<screen>We can combine the modifiers shown above for expressing complex sequence generations or
more clearly expressing the intent of our comprehension:

[source, clojure]</screen>
<simpara>(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]
      :when (= z 6)]
  [x y])</simpara>
<variablelist>
<varlistentry>
<term></term>
<listitem>
<simpara>&#8658; ([1 5] [2 4])</simpara>
</listitem>
</varlistentry>
</variablelist>
<screen>When we outlined the most common usages of the `for` construct in imperative programming languages,
we mentioned that sometimes we want to run a computation for every value in a sequence, not caring
about the result. Presumably we do this for achieving some sort of side-effect with the values of
the sequence.

ClojureScript provides the `doseq` construct, which is analogous to `for` but executes the expression,
discards the resulting values, and returns `nil`.

[source, clojure]</screen>
<simpara>(doseq [x [1 2 3]
        y [4 5]
       :let [z (+ x y)]]
  (println x "+" y "=" z))</simpara>
<variablelist>
<varlistentry>
<term></term>
<listitem>
<simpara>1 + 4 = 5</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term></term>
<listitem>
<simpara>1 + 5 = 6</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term></term>
<listitem>
<simpara>2 + 4 = 6</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term></term>
<listitem>
<simpara>2 + 5 = 7</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term></term>
<listitem>
<simpara>3 + 4 = 7</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term></term>
<listitem>
<simpara>3 + 5 = 8</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term></term>
<listitem>
<simpara>&#8658; nil</simpara>
</listitem>
</varlistentry>
</variablelist>
<screen>=== Collection types


==== Immutable and persistent

We mentioned before that ClojureScript collections are persistent and immutable, but we didn't explain what
that meant.

An immutable data structure, as its name suggest, is a data structure that can not be changed. In-place
updates are not allowed in immutable data structures.

A persistent data structure is a data structure that returns a new version of itself when transforming
it, leaving the original unmodified. ClojureScript makes this memory and time efficient using an
implementation technique called _structural sharing_, where most of the data shared between two versions
of a value is not duplicated, and transformations of a value are implemented by copying the minimal amount of data
required.

////
I'm not sure you need to go into the following example. Remember, these are beginners.
It's nice for them to know that there is sharing, but they don't need a proof. The example
doesn't really advance their general knowledge of the language, either. Instead, I'd conclude
the preceding paragraph with:

We could write an example program to show this in action, but for now, just trust ClojureScript
to use sharing to keep memory use low and speed high, and let’s move on.

////

Let's see an example of appending values to a vector using the `conj` (for "conjoin") operation:

[source, clojure]</screen>
<simpara>(let [xs [1 2 3]
      ys (conj xs 4)]
  (println "xs:" xs)
  (println "ys:" ys))</simpara>
<variablelist>
<varlistentry>
<term></term>
<listitem>
<simpara>xs: [1 2 3]</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term></term>
<listitem>
<simpara>ys: [1 2 3 4]</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term></term>
<listitem>
<simpara>&#8658; nil</simpara>
</listitem>
</varlistentry>
</variablelist>
<screen>As you can see, we derived a new version of the `xs` vector appending an element to it and got a new
vector `ys` with the element added. However, the `xs` vector remained unchanged, because it is immutable.

For illustrating the structural sharing of ClojureScript data structures, let's compare whether some parts
of the old and new versions of a data structure are actually the same object with the `identical?` predicate.
We'll use the list data type for this purpose:

[source, clojure]</screen>
<simpara>(let [xs (list 1 2 3)
      ys (cons 0 xs)]
  (println "xs:" xs)
  (println "ys:" ys)
  (println "(rest ys):" (rest ys))
  (identical? xs (rest ys)))</simpara>
<variablelist>
<varlistentry>
<term></term>
<listitem>
<simpara>xs: (1 2 3)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term></term>
<listitem>
<simpara>ys: (0 1 2 3)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term></term>
<listitem>
<simpara>(rest ys): (1 2 3)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term></term>
<listitem>
<simpara>&#8658; true</simpara>
</listitem>
</varlistentry>
</variablelist>
<screen>As you can see in the example, we used `cons` (construct) to prepend a value to the `xs` list and we got
a new list `ys` with the element added. The `rest` of the `ys` list (all the values but the first)
are the same object in memory as the `xs` list, thus `xs` and `ys` share structure.



==== The sequence abstraction

One of the central ClojureScript abstractions is the _sequence_, which can be thought of as a list and can be derived
from any of the collection types. It is persistent and immutable like all collection types, and many of the
core ClojureScript functions return sequences.

The types that can be used to generate a sequence are called "seqables"; we can call `seq` on them and get
a sequence back. Sequences support two basic operations: `first` and `rest`. They both call `seq` on the
argument we provide them:

[source, clojure]</screen>
<simpara>(first [1 2 3])
;; &#8658; 1</simpara>
<simpara>(rest [1 2 3])
;; &#8658; (2 3)</simpara>
<screen>Calling `seq` on a seqable can yield different results if the seqable is empty or not. It will return `nil`
when empty and a sequence otherwise:

[source, clojure]</screen>
<simpara>(seq [])
;; &#8658; nil</simpara>
<simpara>(seq [1 2 3])
;; &#8658; (1 2 3)</simpara>
<screen>`next` is a similar sequence operation to `rest`, but it differs from the latter in that it yields a `nil` value
when called with a sequence with one or zero elements. Note that, when given one of the aforementioned sequences,
the empty sequence returned by `rest` will evaluate as a boolean true whereas the `nil` value returned by `next`
will evaluate as false (xref:truthiness-section[see the section on _truthiness_ later in this chapter]).

[source, clojure]</screen>
<simpara>(rest [])
;; &#8658; ()</simpara>
<simpara>(next [])
;; &#8658; nil</simpara>
<simpara>(rest [1 2 3])
;; &#8658; (2 3)</simpara>
<simpara>(next [1 2 3])
;; &#8658; (2 3)</simpara>
<screen>////
This seems like a very advanced concept for the first chapter.
TODO: think about this.
////

===== nil-punning

The above behaviour of `seq` when coupled with the falsey nature of `nil` in boolean contexts make it an idiom for checking
the emptyness of a sequence in ClojureScript, which is often referred to as nil-punning.

[source, clojure]</screen>
<simpara>(defn print-coll
  [coll]
  (when (seq coll)
    (println "Saw " (first coll))
    (recur (rest coll))))</simpara>
<simpara>(print-coll [1 2 3])
;; Saw 1
;; Saw 2
;; Saw 3
;; &#8658; nil</simpara>
<simpara>(print-coll #{1 2 3})
;; Saw 1
;; Saw 3
;; Saw 2
;; &#8658; nil</simpara>
<screen>`nil` is also both a seqable and a sequence, and thus it supports all the functions we saw so far:

[source, clojure]</screen>
<simpara>(seq nil)
;; &#8658; nil</simpara>
<simpara>(first nil)
;; &#8658; nil</simpara>
<simpara>(rest nil)
;; &#8658; ()</simpara>
<screen>===== Functions that work on sequences

The ClojureScript core functions for transforming collections make sequences out of their arguments and are
implemented in terms of the generic sequence operations we learned about in the preceding section. This makes
them highly generic, since we can use them on any data type that is seqable. Let's see how we can use `map` with
a variety of seqables:

[source, clojure]</screen>
<simpara>(map inc [1 2 3])
;; &#8658; (2 3 4)</simpara>
<simpara>(map inc #{1 2 3})
;; &#8658; (2 4 3)</simpara>
<simpara>(map count {:a 41 :b 40})
;; &#8658; (2 2)</simpara>
<simpara>(map inc '(1 2 3))
;; &#8658; (2 3 4)</simpara>
<screen>As you may have noticed, functions that operate on sequences are safe to use with empty collections or even
`nil` values since they don't need to do anything but return an empty sequence when encountering such values.

[source, clojure]</screen>
<simpara>(map inc [])
;; &#8658; ()</simpara>
<simpara>(map inc #{})
;; &#8658; ()</simpara>
<simpara>(map inc nil)
;; &#8658; ()</simpara>
<screen>We already saw examples with the usual suspects like `map`, `filter` and `reduce`, but ClojureScript offers a
plethora of generic sequence operations in its core namespace. Note that many of the operations we'll learn about
either work with seqables or are extensible to user defined types.

We can query a value to know whether it's a collection type with the `coll?` predicate:
[source, clojure]</screen>
<simpara>(coll? nil)
;; &#8658; false</simpara>
<simpara>(coll? [1 2 3])
;; &#8658; true</simpara>
<simpara>(coll? {:language "ClojureScript" :file-extension "cljs"})
;; &#8658; true</simpara>
<simpara>(coll? "ClojureScript")
;; &#8658; false</simpara>
<screen>Similar predicates exist for checking if a value is sequence (`seq?`) or a seqable (`seqable?`):
[source, clojure]</screen>
<simpara>(seq? nil)
;; &#8658; false
(seqable? nil)
;; &#8658; false</simpara>
<simpara>(seq? [])
;; &#8658; false
(seqable? [])
;; &#8658; true</simpara>
<simpara>(seq? #{1 2 3})
;; &#8658; false
(seqable? #{1 2 3})
;; &#8658; true</simpara>
<simpara>(seq? "ClojureScript")
;; &#8658; false
(seqable? "ClojureScript")
;; &#8658; false</simpara>
<screen>For collections that can be counted in constant time, we can use the `count` operation:

[source, clojure]</screen>
<simpara>(count nil)
;; &#8658; 0</simpara>
<simpara>(count [1 2 3])
;; &#8658; 3</simpara>
<simpara>(count {:language "ClojureScript" :file-extension "cljs"})
;; &#8658; 2</simpara>
<simpara>(count "ClojureScript")
;; &#8658; 13</simpara>
<screen>We can also get an empty variant of a given collection with the `empty` function:

[source, clojure]</screen>
<simpara>(empty nil)
;; &#8658; nil</simpara>
<simpara>(empty [1 2 3])
;; &#8658; []</simpara>
<simpara>(empty #{1 2 3})
;; &#8658; #{}</simpara>
<screen>The `empty?` predicate returns true if the given collection is empty:

[source, clojure]</screen>
<simpara>(empty? nil)
;; &#8658; true</simpara>
<simpara>(empty? [])
;; &#8658; true</simpara>
<simpara>(empty? #{1 2 3})
;; &#8658; false</simpara>
<screen>The `conj` operation adds elements to collections and may add them in different "places" depending
on the type of collection. It adds them where it is most performant for the collection type,
but note that not every collection has a defined order.

We can pass as many elements we want to add to `conj`; let's see it in action:

[source, clojure]</screen>
<simpara>(conj nil 42)
;; &#8658; (42)</simpara>
<simpara>(conj [1 2] 3)
;; &#8658; [1 2 3]</simpara>
<simpara>(conj [1 2] 3 4 5)
;; &#8658; [1 2 3 4 5]</simpara>
<simpara>(conj '(1 2) 0)
;; &#8658; (0 1 2)</simpara>
<simpara>(conj #{1 2 3} 4)
;; &#8658; #{1 3 2 4}</simpara>
<simpara>(conj {:language "ClojureScript"} [:file-extension "cljs"])
;; &#8658; {:language "ClojureScript", :file-extension "cljs"}</simpara>
<screen>===== Laziness

Most of ClojureScript's sequence-returning functions generate lazy sequences instead of eagerly creating
a whole new sequence. Lazy sequences generate their contents as they are requested, usually when iterating
over them. Laziness ensures that we don't do more work than we need to and gives us the possibility of
treating potentially infinite sequences as regular ones.

////
TODO: This needs a lot more elaboration, and examples showing how lazy sequences behave &amp; how to create them.
////

==== Collections in depth

Now that we're acquainted with ClojureScript's sequence abstraction and some of the generic sequence manipulating
functions, it's time to dive into the concrete collection types and the operations they support.


===== Lists

In ClojureScript lists are mostly used as a data structure for grouping symbols together into programs. Unlike in other
Lisps, many of the syntactic constructs of ClojureScript use data structures different from the list (vectors and maps).
This makes code less uniform, but the gains in readability are well worth the price.

You can think of ClojureScript lists as singly linked lists, where each node contains a value and a pointer to the rest of the list.
This makes it natural (and fast!) to add items to the front of the list, since adding to the end would require traversal of the entire
list. The prepend operation is performed using the `cons` (construct) function.

[source, clojure]</screen>
<simpara>(cons 0 (cons 1 (cons 2 ())))
;; &#8658; (0 1 2)</simpara>
<screen>We used the literal `()` to represent the empty list. Since it doesn't contain any symbols, it is not treated
as a function call. However, when using list literals that contain elements, we need to quote them to
prevent ClojureScript from evaluating them as a function call:

[source, clojure]</screen>
<simpara>(cons 0 '(1 2))
;; &#8658; (0 1 2)</simpara>
<screen>Since the head is the position that has constant time addition in the list collection, the `conj` operation
on lists naturally adds item in the front:

[source, clojure]</screen>
<simpara>(conj '(1 2) 0)
;; &#8658; (0 1 2)</simpara>
<screen>Lists and other ClojureScript data structures can be used as stacks using the `peek`, `pop`, and `conj` functions.
Note that the top of the stack will be the "place" where `conj` adds elements, making `conj` equivalent to the
stack's push operation. In the case of lists, `conj` adds elements to the front of the list, `peek` returns the first
element of the list, and `pop` returns a list with all the elements but the first one.

Note that the two operations that return a stack (`conj` and `pop`) don't change the type of the collection used for
the stack.

[source, clojure]</screen>
<simpara>(def list-stack '(0 1 2))</simpara>
<simpara>(peek list-stack)
;; &#8658; 0</simpara>
<simpara>(pop list-stack)
;; &#8658; (1 2)</simpara>
<simpara>(type (pop list-stack))
;; &#8658; cljs.core/List</simpara>
<simpara>(conj list-stack -1)
;; &#8658; (-1 0 1 2)</simpara>
<simpara>(type (conj list-stack -1))
;; &#8658; cljs.core/List</simpara>
<screen>One thing that lists are not particularly good at is random indexed access. Since they are stored in a single linked list-like
structure in memory, random access to a given index requires a linear traversal in order to either retrieve the requested
item or throw an index out of bounds error. Non-indexed ordered collections like lazy sequences also suffer from this limitation.


===== Vectors

Vectors are one of the most common data structures in ClojureScript. They are used as a syntactic construct in many
places where more traditional Lisps use lists, for example in function argument declarations and `let` bindings.

ClojureScript vectors have enclosing brackets `[]` in their syntax literals. They can be created with `vector` and from
another collection with `vec`:

[source,clojure]</screen>
<simpara>(vector? [0 1 2])
;; &#8658; true</simpara>
<simpara>(vector 0 1 2)
;; &#8658; [0 1 2]</simpara>
<simpara>(vec '(0 1 2))
;; &#8658; [0 1 2]</simpara>
<screen>Vectors are, like lists, ordered collections of heterogeneous values. Unlike lists, vectors grow naturally from the tail,
so the `conj` operation appends items to the end of a vector. Insertion on the end of a vector is effectively constant
time:

[source,clojure]</screen>
<simpara>(conj [0 1] 2)
;; &#8658; [0 1 2]</simpara>
<screen>Another thing that differentiates lists and vectors is that vectors are indexed collections and as such support efficient
random index access and non-destructive updates. We can use the familiar `nth` function to retrieve values given an index:

[source, clojure]</screen>
<simpara>(nth [0 1 2] 0)
;; &#8658; 0</simpara>
<screen>Since vectors associate sequential numeric keys (indexes) to values, we can treat them as an associative data structure. ClojureScript
provides the `assoc` function that, given an associative data structure and a set of key-value pairs, yields a new data structure with
the values corresponding to the keys modified. Indexes begin at zero for the first element in a vector.

[source, clojure]</screen>
<simpara>(assoc ["cero" "uno" "two"] 2 "dos")
;; &#8658; ["cero" "uno" "dos"]</simpara>
<screen>Note that we can only `assoc` to a key that is either contained in the vector already or if it's the last position in a vector:

[source, clojure]</screen>
<simpara>(assoc ["cero" "uno" "dos"] 3 "tres")
;; &#8658; ["cero" "uno" "dos" "tres"]</simpara>
<simpara>(assoc ["cero" "uno" "dos"] 4 "cuatro")
;; Error: Index 4 out of bounds [0,3]</simpara>
<screen>Perhaps surprisingly, associative data structures can also be used as functions. They are functions of their keys to the values they
are associated with. In the case of vectors, if the given key is not present an exception is thrown:

[source, clojure]</screen>
<simpara>(["cero" "uno" "dos"] 0)
;; &#8658; "cero"</simpara>
<simpara>(["cero" "uno" "dos"] 2)
;; &#8658; "dos"</simpara>
<simpara>(["cero" "uno" "dos"] 3)
;; Error: Not item 3 in vector of length 3</simpara>
<screen>As with lists, vectors can be also used as stack with the `peek`, `pop` and `conj` functions. Note, however, that vectors grow
from the opposite end of the collection as lists:

[source, clojure]</screen>
<simpara>(def vector-stack [0 1 2])</simpara>
<simpara>(peek vector-stack)
;; &#8658; 2</simpara>
<simpara>(pop vector-stack)
;; &#8658; [0 1]</simpara>
<simpara>(type (pop vector-stack))
;; &#8658; cljs.core/PersistentVector</simpara>
<simpara>(conj vector-stack 3)
;; &#8658; [0 1 2 3]</simpara>
<simpara>(type (conj vector-stack 3))
;; &#8658; cljs.core/PersistentVector</simpara>
<screen>The `map` and `filter` operations return lazy sequences, but as it is common to need a fully realized sequence after performing those operations,
vector-returning counterparts of such functions are available as `mapv` and `filterv`. They have the advantages of being faster
than building a vector from a lazy sequence and making your intent more explicit:

[source, clojure]</screen>
<simpara>(map inc [0 1 2])
;; &#8658; (1 2 3)</simpara>
<simpara>(type (map inc [0 1 2]))
;; &#8658; cljs.core/LazySeq</simpara>
<simpara>(mapv inc [0 1 2])
;; &#8658; [1 2 3]</simpara>
<simpara>(type (mapv inc [0 1 2]))
;; &#8658; cljs.core/PersistentVector</simpara>
<screen>===== Maps

Maps are ubiquitous in ClojureScript. Like vectors, they are also used as a syntactic construct for attaching metadata to
vars. Any ClojureScript data structure can be used as a key in a map, although it's common to use keywords since can also
be called as functions.

////
Joe the Beginning Programmer asks: "What do you mean by 'attaching metadata to vars'? I'm conufsed."
////

ClojureScript maps are written literally as key-value pairs enclosed in braces `{}`. Alternatively, they can be created
with the `hash-map` function:

[source,clojure]</screen>
<simpara>(map? {:name "Cirilla"})
;; &#8658; true</simpara>
<simpara>(hash-map :name "Cirilla")
;; &#8658; {:name "Cirilla"}</simpara>
<simpara>(hash-map :name "Cirilla" :surname "Fiona")
;; &#8658; {:name "Cirilla" :surname "Fiona"}</simpara>
<screen>Since regular maps don't have a specific order, the `conj` operation just adds one or more key-value pairs to a map. `conj`
for maps expects one or more sequences of key-value pairs as its last arguments:

[source,clojure]</screen>
<simpara>(def ciri {:name "Cirilla"})</simpara>
<simpara>(conj ciri [:surname "Fiona"])
;; &#8658; {:name "Cirilla", :surname "Fiona"}</simpara>
<simpara>(conj ciri [:surname "Fiona"] [:occupation "Wizard"])
;; &#8658; {:name "Cirilla", :surname "Fiona", :occupation "Wizard"}</simpara>
<screen>In the preceding example, it just so happens that the order was preserved, but if you have many keys, you will see that
the order is not preserved.

Maps associate keys to values and, as such, are an associative data structure. They support adding associations with `assoc` and,
unlike vectors, removing them with `dissoc`. Let's explore these functions:

[source,clojure]</screen>
<simpara>(assoc {:name "Cirilla"} :surname "Fiona")
;; &#8658; {:name "Cirilla", :surname "Fiona"}</simpara>
<simpara>(dissoc {:name "Cirilla"} :name)
;; &#8658; {}</simpara>
<screen>Maps are also functions of their keys, returning the values related to the given key. Unlike vectors, they return `nil` if we supply
a key that is not present in the map:

[source,clojure]</screen>
<simpara>({:name "Cirilla"} :name)
;; &#8658; "Cirilla"</simpara>
<simpara>({:name "Cirilla"} :surname)
;; &#8658; nil</simpara>
<screen>ClojureScript also offers sorted hash maps which behave like their unsorted versions but preserve order when iterating over them. We
can create a sorted map with default ordering with `sorted-map`:

[source,clojure]</screen>
<simpara>(def sm (sorted-map :c 2 :b 1 :a 0))
;; &#8658; {:a 0, :b 1, :c 2}</simpara>
<simpara>(keys sm)
;; &#8658; (:a :b :c)</simpara>
<screen>If we need a custom ordering we can provide a comparator function to `sorted-map-by`, let's see an example inverting the value
returned by the built-in `compare` function. Comparator functions take two elements to compare and returns -1 (less than), 0 (equal)
or 1 (greater than):

[source,clojure]</screen>
<simpara>(def reverse-compare (comp - compare))</simpara>
<simpara>(def sm (sorted-map-by reverse-compare :a 0 :b 1 :c 2))
;; &#8658; {:c 2, :b 1, :a 0}</simpara>
<simpara>(keys sm)
;; &#8658; (:c :b :a)</simpara>
<screen>===== Sets

Sets in ClojureScript have literal syntax as values enclosed in `#{}` and they can be created with the `set` constructor. They are
unordered collections of values without duplicates.

[source,clojure]</screen>
<simpara>(set? #{\a \e \i \o \u})
;; &#8658; true</simpara>
<simpara>(set [1 1 2 3])
;; &#8658; #{1 2 3}</simpara>
<screen>Set literals can not contain duplicate values. If you accidentaly write a set literal with duplicates an error will be thrown:

[source,clojure]</screen>
<simpara>#{1 1 2 3}
;; clojure.lang.ExceptionInfo: Duplicate key: 1</simpara>
<screen>There are many operations that can be performed with sets, although they are located in the `clojure.set` namespace and thus need to be imported.
You'll learn xref:namespace-section[the details of namespacing] later; for now you only need to know that we are loading a namespace called `clojure.set` and binding
it to the `s` symbol.

[source,clojure]</screen>
<simpara>(require '[clojure.set :as s])</simpara>
<simpara>(def danish-vowels #{\a \e \i \o \u \æ \ø \å})
;; &#8658; #{"a" "e" "å" "æ" "i" "o" "u" "ø"}</simpara>
<simpara>(def spanish-vowels #{\a \e \i \o \u})
;; &#8658; #{"a" "e" "i" "o" "u"}</simpara>
<simpara>(s/difference danish-vowels spanish-vowels)
;; &#8658; #{"å" "æ" "ø"}</simpara>
<simpara>(s/union danish-vowels spanish-vowels)
;; &#8658; #{"a" "e" "å" "æ" "i" "o" "u" "ø"}</simpara>
<simpara>(s/intersection danish-vowels spanish-vowels)
;; &#8658; #{"a" "e" "i" "o" "u"}</simpara>
<screen>A nice property of immutable sets is that they can be nested. Languages that have mutable sets can end up containing duplicate values, but
that can't happen in ClojureScript. In fact, all ClojureScript data structures can be nested arbitrarily due to immutability.

Sets also support the generic `conj` operation, as every other collection does.

[source,clojure]</screen>
<simpara>(def spanish-vowels #{\a \e \i \o \u})
;; &#8658; #{"a" "e" "i" "o" "u"}</simpara>
<simpara>(def danish-vowels (conj spanish-vowels \æ \ø \å))
;; &#8658; #{"a" "e" "i" "o" "u" "æ" "ø" "å"}</simpara>
<simpara>(conj #{1 2 3} 1)
;; &#8658; #{1 3 2}</simpara>
<screen>Sets act as read-only associative data that associates the values it contains to themselves. Since every value except `nil` and `false` is
truthy in ClojureScript, we can use sets as predicate functions:

[source,clojure]</screen>
<simpara>(def vowels #{\a \e \i \o \u})
;; &#8658; #{"a" "e" "i" "o" "u"}</simpara>
<simpara>(get vowels \b)
;; &#8658; nil</simpara>
<simpara>(contains? vowels \b)
;; &#8658; false</simpara>
<simpara>(vowels \a)
;; &#8658; "a"</simpara>
<simpara>(filter vowels "Hound dog")
;; &#8658; ("o" "u" "o")</simpara>
<screen>Sets have a sorted counterpart like maps do, created using the functions `sorted-set` and `sorted-set-by` which are analogous to map's `sorted-map` and `sorted-map-by`.

[source,clojure]</screen>
<simpara>(def unordered-set #{[0] [1] [2]})
;; &#8658; #{[0] [2] [1]}</simpara>
<simpara>(seq unordered-set)
;; &#8658; ([0] [2] [1])</simpara>
<simpara>(def ordered-set (sorted-set [0] [1] [2]))
;; &#8658;# {[0] [1] [2]}</simpara>
<simpara>(seq unordered-set)
;; &#8658; ([0] [1] [2])</simpara>
<screen>===== Queues

////
I'm not sure that this section is necessary for beginners, but I am OK with it.
////

ClojureScript also provides a persistent and immutable queue. Queues don't have literal syntax since they are not used as pervasively as other collection types.

There are no convenient constructor functions for creating persistent queues. Instead of that, we can get an empty instance using `PersistentQueue`s
`EMPTY` attribute.

[source,clojure]</screen>
<simpara>(def pq (.-EMPTY PersistentQueue))
;; &#8658; #queue []</simpara>
<screen>Using `conj` to add values to a queue adds items onto the rear:

[source,clojure]</screen>
<simpara>(def pq (.-EMPTY PersistentQueue))
;; &#8658; #queue []</simpara>
<simpara>(conj (.-EMPTY PersistentQueue) 1 2 3)
;; &#8658; #queue [1 2 3]</simpara>
<screen>A thing to bear in mind about queues is that the stack operations don't follow the usual stack semantics (pushing and popping from the same end). `pop`
takes values from the front position, and `conj` pushes (appends) elements to the back.

[source,clojure]</screen>
<simpara>(def pq (conj (.-EMPTY PersistentQueue) 1 2 3))
;; &#8658; #queue [1 2 3]</simpara>
<simpara>(peek pq)
;; &#8658; 1</simpara>
<simpara>(pop pq)
;; &#8658; #queue [2 3]</simpara>
<simpara>(conj pq 4)
;; &#8658; #queue [1 2 3 4]</simpara>
<screen>Queues are not as frequently used as lists or vectors, but it is good to know that they are available in ClojureScript, as they may occasionally come in handy.


=== Destructuring

Destructuring, as its name suggests, is a way of taking apart structured data such as collections and focusing on individual parts of them. ClojureScript
offers a concise syntax for destructuring both indexed sequences and associative data structures that can be used any place where bindings are declared.

Let's see an example of what destructuring is useful for, since it'll help us understand the previous statements better. Imagine that you have a sequence
but are only interested in the first and third item. You could get a reference to them easily with the `nth` function:

[source, clojure]</screen>
<simpara>(let [v [0 1 2]
      fst (nth v 0)
      thrd (nth v 2)]
  [thrd fst])
;; &#8658; [2 0]</simpara>
<screen>However, the previous code is overly verbose. Destructuring lets us extract values of indexed sequences more succintly using a vector in the left-hand side of a binding:

[source, clojure]</screen>
<simpara>(let [[fst _ thrd] [0 1 2]]
  [thrd fst])
;; &#8658; [2 0]</simpara>
<screen>In the above example, `[fst _ thrd]` is a destructuring form. It is represented as a vector and used for binding indexed values to the symbols `fst` and
`thrd`, corresponding to the index `0` and `2` respectively. The `_` symbol is used as a placeholder for indexes we are not interested in, in this case `1`.

Note that destructuring is not limited to the `let` binding form; it works in almost every place where we bind values to symbols such as in the `for` and `doseq`
special forms or function arguments. We can write a function that takes a pair and swaps its positions very concisely using destructuring syntax in functionn
arguments:

[source, clojure]</screen>
<simpara>(defn swap-pair [[fst snd]]
  [snd fst])</simpara>
<simpara>(swap-pair [1 2])
;; &#8658; [2 1]</simpara>
<simpara>(swap-pair '(3 4))
;; &#8658; [4 3]</simpara>
<screen>Positional destructuring with vectors is quite handy for taking indexed values out of sequences, but sometimes we don't want to discard the rest of
the elements in the sequence when destructuring. Similarly to how `&amp;` is used for accepting variadic function arguments, the ampersand can be used inside a vector
destructuring form for grouping together the rest of a sequence:

[source, clojure]</screen>
<simpara>(let [[fst snd &amp; more] (range 10)]
  {:first fst
   :snd snd
   :rest more})
;; &#8658; {:first 0, :snd 1, :rest (2 3 4 5 6 7 8 9)}</simpara>
<screen>Notice how the value in the `0` index got bound to `fst`, the value in the `1` index got bound to `snd` and the sequence of elements from `2` onwards got
bound to the `more` symbol.

We may still be interested in a data structure as a whole even when we are destructuring it. This can be achieved with the `:as` keyword. If used inside
a destructuring form, the original data structure is bound to the symbol following that keyword:

[source, clojure]</screen>
<simpara>(let [[fst snd &amp; more :as original] (range 10)]
  {:first fst
   :snd snd
   :rest more
   :original original})
;; &#8658; {:first 0, :snd 1, :rest (2 3 4 5 6 7 8 9), :original (0 1 2 3 4 5 6 7 8 9)}</simpara>
<screen>Not only indexed sequences can be destructured, associative data can also be destructured. Its destructuring binding form is represented as a map instead of
a vector, where the keys are the symbols we want to bind values to and the values are the keys that we want to look up in the associative data structure. Let's
see an example:

[source, clojure]</screen>
<simpara>(let [{language :language} {:language "ClojureScript"}]
  language)
;; &#8658; "ClojureScript"</simpara>
<screen>In the above example, we are extracting the value associated with the `:language` key and binding it to the `language` symbol. When looking up keys that are
not present, the symbol will get bound to `nil`:

[source, clojure]</screen>
<simpara>(let [{name :name} {:language "ClojureScript"}]
  name)
;; &#8658; nil</simpara>
<screen>Associative destructuring lets us give default values to bindings, which will be used if the key isn't found in the data structure we are taking apart. A map
following the `:or` keyword is used for default values, as the following examples show:

[source, clojure]</screen>
<simpara>(let [{name :name :or {name "Anonymous"}} {:language "ClojureScript"}]
  name)
;; &#8658; "Anonymous"</simpara>
<simpara>(let [{name :name :or {name "Anonymous"}} {:name "Cirilla"}]
  name)
;; &#8658; "Cirilla"</simpara>
<screen>Associative destructuring also supports binding the original data structure to a symbol placed after the `:as` keyword:

[source, clojure]</screen>
<simpara>(let [{name :name :as person} {:name "Cirilla" :age 49}]
  [name person])
;; &#8658; ["Cirilla" {:name "Cirilla" :age 49}]</simpara>
<screen>Not only keywords can be the keys of associative data structures. Numbers, strings, symbols and many other data structures can
be used as keys, so we can destructure using those too. Note that we need to quote the symbols to prevent them from being
resolved as a var lookup:

[source, clojure]</screen>
<simpara>(let [{tenth 10} (range 100)]
  tenth)
;; &#8658; 11</simpara>
<simpara>(let [{name "name"} {"name" "Cirilla"}]
  name)
;; &#8658; "Cirilla"</simpara>
<simpara>(let [{lang 'language} {'language "ClojureScript"}]
  lang)
;; &#8658; "ClojureScript"</simpara>
<screen>Since usually the values corresponding to keys are bound to their equivalent symbol representation (for example, when binding the value of `:language` to the `language`)
and keys are usually keywords, strings or symbols ClojureScript offers shorthand syntax for these cases.

We'll show examples of all, starting with destructuring keywords using `:keys`:

[source, clojure]</screen>
<simpara>(let [{:keys [name surname]} {:name "Cirilla" :surname "Fiona"}]
  [name surname])
;; &#8658; ["Cirilla" "Fiona"]</simpara>
<screen>As you can see in the example, if we use the `:keys` keyword and associate it with a vector of symbols in a binding form, the values
corresponding to the keywordized version of the symbols will be bound to them. The `{:keys [name surname]}` destructuring is equivalent
to `{name :name surname :surname}`, only shorter.

The string and symbol shorthand syntax works exactly like `:keys`, but using the `:strs` and `:syms` keywords respectively:

[source, clojure]</screen>
<simpara>(let [{:strs [name surname]} {"name" "Cirilla" "surname" "Fiona"}]
  [name surname])
;; &#8658; ["Cirilla" "Fiona"]</simpara>
<simpara>(let [{:syms [name surname]} {'name "Cirilla" 'surname "Fiona"}]
  [name surname])
;; &#8658; ["Cirilla" "Fiona"]</simpara>
<screen>An interesting property of destructuring is that we can nest destructuring forms arbitrarily, which makes code that accesses nested data
on a collection very easy to understand as it mimics the collection's structure:

[source, clojure]</screen>
<simpara>(let [{[fst snd] :languages} {:languages ["ClojureScript" "Clojure"]}]
  [snd fst])
;; &#8658; ["Clojure" "ClojureScript"]</simpara>
<screen>[[namespace-section]]
=== Namespaces

==== Defining a namespace

The _namespace_ is ClojureScript's fundamental unit of code modularity. Namespaces are analogous to Java packages or
Ruby and Python modules, and can be defined with the `ns` macro. Maybe if you have looked at a little bit of
ClojureScript source you have seen something like this at begining of the file:

[source, clojure]</screen>
<simpara>(ns myapp.core
  "Some docstring for the namespace.")</simpara>
<simpara>(def x "hello")</simpara>
<screen>Namespaces are dynamic, meaning you can create one at any time. The convention however, is to have one namespace
per file. Naturally, a namespace definition is usually at the beginning of the file, followed by an optional
docstring.

Previously we have explained vars and symbols. Every var that you define will be associated
with its namespace. If you do not define a concrete namespace, then the default one called "user" will be
used:

[source, clojure]</screen>
<simpara>(def x "hello")
;; &#8658; #'user/x</simpara>
<screen>==== Loading other namespaces

Defining a namespace and the vars in it is really easy, but it's not very useful if we can't
use symbols from other namespaces. For this purpose, the `ns` macro offers a simple way to load other
namespaces.

Observe the following:

[source, clojure]</screen>
<simpara>(ns myapp.main
  (:require myapp.core
            clojure.string))</simpara>
<simpara>(clojure.string/upper-case myapp.core/x)
;; &#8658; "HELLO"</simpara>
<screen>As you can observe, we are using fully qualified names (namespace + var name) for access to vars and
functions from different namespaces.

While this will let you access other namespaces, it's also repetitive and overly verbose. It will be especially
uncomfortable if the name of a namespace is very long. To solve that, you can use the `:as` directive to
create an additional (usually shorter) alias to the namespace.
This is how it can be done:

[source, clojure]</screen>
<simpara>(ns myapp.main
  (:require [myapp.core :as core]
            [clojure.string :as str]))</simpara>
<simpara>(str/upper-case core/x)
;; &#8658; "HELLO"</simpara>
<screen>Additionaly, _ClojureScript_ offers a simple way to refer to specific vars or functions from a concrete namespace using the `:refer` directive.

The `:refer` directive has two possible arguments: the `:all` keyword or a vector of symbols that will
refer to vars in the namespace. With `:all`, we are indicating that we want to refer all public vars from the
namespace, and with vector we can specify the specific subset of vars that we want. Effectively, it is as if those vars and
functions are now part of your namespace, and you do not need to qualify them at all.

[source, clojure]</screen>
<simpara>(ns myapp.main
  (:require [myapp.core :refer :all]
            [clojure.string :refer [upper-case]]))
(upper-case x)
;; &#8658; "HELLO"</simpara>
<screen>And finally, you should know that everything located in the `cljs.core` namespace is automatically
loaded and you should not require it explicitly. Sometimes you may want declare vars that will clash
with some others defined in the `cljs.core` namespace. To do this, the `ns` macro offers another directive that
allows you to exclude specific symbols and prevent them from being automatically loaded.

Observe the following:

[source, clojure]</screen>
<simpara>(ns myapp.main
  (:refer-clojure :exclude [min]))</simpara>
<simpara>(defn min
  [x y]
  (if (&gt; x y)
    y
    x))</simpara>
<screen>The `ns` macro also has other directives for loading host classes (`:import`) and macros
(`:refer-macros`), but these are explained in other sections.


=== Abstractions and Polymorphism

I'm sure that at more than one time you have found yourself in this situation: you have defined a great
abstraction (using interfaces or something similar) for your "business logic" and you have found
the need to deal with another module over which you have absolutely no control, and you probably
were thinking of creating adapters, proxies, and other approaches that imply a great amount
of additional complexity.

Some dynamic languages allow "monkey-patching"; languages where the classes are open and any
method can be defined and redefined at any time. Also, it is well known that this technique is a very
bad practice.

We can not trust languages that allow you to silently overwrite methods that you are using when you import third party libraries; you can not expect
consistent behavior when this happens.

These symptoms are commonly called the "expression problem";
see http://en.wikipedia.org/wiki/Expression_problem for more details

==== Protocols

The _ClojureScript_ primitive for defining "interfaces" is called a Protocol. A protocol consists of
a name and set of functions. All the functions have at least one argument corresponding to the
`this` in JavaScript or `self` in Python.

Protocols provide a type-based polymorphism, and the dispatch is always done by the
first argument (equivalent to JavaScript’s `this`, as previously mentioned).

A protocol looks like this:

[source, clojure]</screen>
<simpara>(ns myapp.testproto)</simpara>
<simpara>(defprotocol IProtocolName
  "A docstring describing the protocol."
  (sample-method [this] "A doc string of the function associated with the protocol."))</simpara>
<screen>NOTE: the "I" prefix is commonly used to designate the separation of protocols and types. In the clojure
community there many different opinions about how the "I" prefix should be used. In our opinion, it is an
acceptable solution to avoid name clashing and possible confusion.

From the user perspective, protocol functions are simply plain functions defined in the namespace
where the protocol is defined. As you can intuit, this namespacing of protocols allows us to avoid
any conflict between different protocols implemented for the same type.

Here is an example. Let's create a protocol called `IInvertible` for data that can be "inverted."
It will have a single method named `invert`

[source, clojure]</screen>
<simpara>(ns proto.testproto)</simpara>
<simpara>(defprotocol IInvertible
  "This is a protocol for data types that are 'invertible'"
    (invert [this] "Invert the given item."))</simpara>
<screen>===== Extending existing types

One of the big strengths of protocols is the ability to extend existing and maybe third party types,
and this operation can be done in different ways. The majority of time you will tend to use
the *extend-protocol* or the *extend-type* macros.

This is an example of how the *extend-type* macro can be used:

[source, clojure]</screen>
<simpara>(extend-type TypeA
  ProtocolA
  (function-from-protocol-a [this]
    ;; implementation here
    )</simpara>
<literallayout class="monospaced">ProtocolB
(function-from-protocol-b-1 [this parameter1]
  ;; implementation here
  )
(function-from-protocol-b-2 [this parameter1 parameter2]
  ;; implementation here
  ))</literallayout>
<screen>You can observe that with *extend-type* you are extending a single type with different protocols
in a single expression.  Here is code that will extend the `number`, `string`, `List`, and
`PersistentVector` types to be "invertible."  For numbers, we define the inverse to be the
reciprocal of the number (or zero, if the number is zero). For strings, lists, and vectors,
the inverse is defined as the reverse of the input.</screen>
<simpara>(extend-type number
  IInvertible
  (invert [this] (if (zero? this) 0 (/ 1 this))))</simpara>
<simpara>(extend-type string
  IInvertible
  (invert [this] (apply str (reverse this))))</simpara>
<simpara>(extend-type List
  IInvertible
  (invert [this] (reverse this)))</simpara>
<simpara>(extend-type PersistentVector
  IInvertible
  (invert [this] (into [] (reverse this))))</simpara>
<screen>If you load in this code, you can see that it works:

[source, clojure]</screen>
<simpara>(proto.testproto/invert "abc")
;; &#8658; "cba"
(proto.testproto/invert 25)
;; &#8658; 0.04
(proto.testproto/invert "abc")
;; &#8658; "cba"
(proto.testproto/invert '(1 2 3))
;; &#8658; (3 2 1)
(proto.testproto/invert [1 2 3])
;; &#8658; [3 2 1]</simpara>
<screen>Admittedly, this is a somewhat contrived example. In xref:extend-type-section[the next section]
you will see how to extend an existing type.

In comparison, *extend-protocol* does the inverse;
given a protocol, it adds implementations for multiple types:

[source, clojure]</screen>
<simpara>(extend-protocol ProtocolA
  TypeA
  (function-from-protocol-a [this]
    ;; implementation here
    )</simpara>
<literallayout class="monospaced">TypeB
(function-from-protocol-a [this]
  ;; implementation here
  ))</literallayout>
<screen>Thus, the previous example could have equally well have been written this way:

[source, clojure]</screen>
<simpara>(extend-protocol IInvertible
  number
  (invert [this] (if (zero? this) 0 (/ 1 this)))</simpara>
<literallayout class="monospaced">string
(invert [this] (apply str (reverse this)))</literallayout>
<literallayout class="monospaced">List
(invert [this] (reverse this))</literallayout>
<literallayout class="monospaced">PersistentVector
(invert [this] (into [] (reverse this))))</literallayout>
<screen>There are other ways to extend a type with a protocol implementation, but they will be covered
in another section of this book.

anchor:extend-type-section[]
===== Participate in ClojureScript abstractions

ClojureScript itself is built up on abstractions defined as protocols. Almost all behavior
in the _ClojureScript_ language itself can be adapted to third party libraries. Let's go to see a
real life example.

In previous sections we have explained the different kinds of built-in collections. For this example we
will use the *Set*. See this snipped of code:

[source, clojure]</screen>
<simpara>(def mynums #{1 2})</simpara>
<simpara>(filter mynums [1 2 4 5 1 3 4 5])
;; &#8658; (1 2 1)</simpara>
<screen>What happened? In this case, the _set_ type implements the _ClojureScript_ internal
`IFn` protocol that represents an abstraction for functions or anything callable. This way it can be
used like a callable predicate in filter.

Ok, but what happens if we want use a regular expression as predicate function for filtering
a collection of strings:

[source, clojure]</screen>
<simpara>(filter #"^foo" ["haha" "foobar" "baz" "foobaz"])
;; TypeError: Cannot call undefined</simpara>
<screen>The exception is raised because the RegExp type does not implements the `IFn` protocol
so it cannot behave like a callable, but that can be easily fixed:

[source, clojure]</screen>
<simpara>(extend-type js/RegExp
  IFn
  (-invoke
   ([this a]
     (re-find this a))))</simpara>
<screen>Let’s analyze this:  we are extending the `js/RegExp` type so that it implements the `invoke` function in the
`IFn` protocol. To invoke a regular expression `a` as if it were a function, call the `re-find` function with
the object of the function and the pattern.

Now, you will be able use the regex instances as predicates in filter operation:

[source, clojure]</screen>
<simpara>(filter #"^foo" ["haha" "foobar" "baz" "foobaz"])
;; &#8658; ("foobar" "foobaz")</simpara>
<screen>===== Introspection using Protocols

_ClojureScript_ comes with a useful function that allows runtime introspection: `satisfies?`. The
purpose of this function is to determinate at runtime if some object (instance of some type) satisfies the
concrete protocol.

So, with previous examples, if we check if a `set` instance satisfies a *IFn* protocol, it should
return `true`:

[source, clojure]</screen>
<simpara>(satisfies? IFn #{1})
;; &#8658; true</simpara>
<screen>==== Multimethods

We have previously talked about protocols, which solve a very common use case of polymorphism:
dispatch by type. But in some circumstances, the protocol approach can be limiting. And
here, *multimethods* come to the rescue.

These *multimethods* are not limited to type dispatch only; instead, they also offer dispatch
by types of multiple arguments and by value. They also allow ad-hoc hierarchies to be defined. Also,
like protocols, multimethods are an "Open System," so you or any third parties can extend a multimethod for
new types.

The basic constructions of *multimethods* are the `defmulti` and `defmethod` forms. The
`defmulti` form is used to create the multimethod with an initial dispatch function. This is
a model of what it looks like:

[source, clojure]</screen>
<simpara>(defmulti say-hello
  "A polymorphic function that return a greetings message
  depending on the language key with default lang as `:en`"
  (fn [param] (:locale param))
  :default :en)</simpara>
<screen>The anonymous function defined within the `defmulti` form is a dispatch function. It will
be called in every call to `say-hello` function and should return some kind of marker object
that will be used for dispatch. In our example it returns the contents of the `:locale` key
of the first argument.

And finally, you should add implementations. That is done with `defmethod` form:

[source, clojure]</screen>
<simpara>(defmethod say-hello :en
  [person]
  (str "Hello " (:name person "Anonymous")))</simpara>
<simpara>(defmethod say-hello :es
  [person]
  (str "Hola " (:name person "Anónimo")))</simpara>
<screen>So, if you execute that function over a hash map containing the `:locale` and optionally
the `:name` key, the multimethod will first call the dispatch function to determine the
dispatch value, then it will search for an implementation for that value. If an implementation
is found, the dispatcher will execute it. Otherwise, the dispatch will search for a default implementation
(if one is specified) and execute it.

[source, clojure]</screen>
<simpara>(say-hello {:locale :es})
;; &#8658; "Hola Anónimo"</simpara>
<simpara>(say-hello {:locale :en :name "Ciri"})
;; &#8658; "Hello Ciri"</simpara>
<simpara>(say-hello {:locale :fr})
;; &#8658; "Hello Anonymous"</simpara>
<screen>If the default implementation is not specified, an exception will be raised notifying you
that some value does not have a implementation for that multimethod.


==== Hierarchies

Hierarchies are _ClojureScript_’s way to let you build whatever relations that your
domain may require. The hierarchies are defined in term of relations between named objects,
such as symbols, keywords or types.

The hierarchies can be defined globally or locally, depending on your needs. Like multimethods,
hierarchies are not limited to a single namespace. You can extend a hierarchy from any namespace,
not necessarily the one in which they are defined.

The global namespace is more limited, for good reasons. Keywords or symbols that are not namespaced can
not be used in the global hierarchy. That behavior helps prevent unexpected situations when
two or more third party libraries use the same symbol for different semantics.


===== Defining a hierarchy

The hierarchy relations should be established using the `derive` function:

[source, clojure]</screen>
<simpara>(derive ::circle ::shape)
(derive ::box ::shape)</simpara>
<screen>We have just defined a set of relationships between namespaced keywords. In this case the
`::circle` is a child of `::shape`, and `::box` is also a child of `::shape`.

TIP: The `::circle` keyword syntax is a shorthand for `:current.ns/circle`. So if you are executing
it in a REPL, `::circle` will be evaluated as `:cljs.user/circle`.


===== Hierarchies and introspection

_ClojureScript_ comes with a little toolset of functions that allow runtime introspection
of globally or locally defined hierarchies. This toolset consists of three functions:
`isa?`, `ancestors`, and `descendants`.

Let's see an example of how it can be used with the hierarchy defined in previous example:

[source, clojure]</screen>
<simpara>(ancestors ::box)
;; &#8658; #{:cljs.user/shape}</simpara>
<simpara>(descendants ::shape)
;; &#8658; #{:cljs.user/circle :cljs.user/box}</simpara>
<simpara>(isa? ::box ::shape)
;; &#8658; true</simpara>
<simpara>(isa? ::rect ::shape)
;; &#8658; false</simpara>
<screen>===== Locally defined hierarchies

As we mentioned previously, in _ClojureScript_ you also can define local hierarchies. This can be
done with the `make-hierarchy` function. Here is an example of how you can replicate the previous
example using a local hierarchy:

////
Have you explained the -&gt; operator?
TODO: add chapter for explain the threading macros
////

[source, clojure]</screen>
<simpara>(def h (&#8594; (make-hierarchy)
           (derive :box :shape)
           (derive :circle :shape)))</simpara>
<screen>Now you can use the same introspection functions with that locally defined hierarchy:

[source, clojure]</screen>
<simpara>(isa? h :box :shape)
;; &#8658; true</simpara>
<simpara>(isa? :box :shape)
;; &#8658; false</simpara>
<screen>As you can observe, in local hierarchies we can use normal (not namespace qualified) keywords,
and if we execute the `isa?` without passing the local hierarchy parameter, it returns `false`
as expected.


===== Hierarchies in multimethods

One of the big advantages of hierarchies is that they works very well together with multimethods.
This is because multimethods by default use the `isa?` function for the last step of dispatching.

Let's see an example to clearly understand what that means. Firstly, define the multimethod with
`defmulti` form:

[source, clojure]</screen>
<simpara>(defmulti stringify-shape
  "A function that prints a human readable representation
  of a shape keyword."
  identity
  :hierarchy h)</simpara>
<screen>With `:hierarchy` keyword parameter we indicate to the multimethod that hierarchy we want to use;
if it is not specified, the global hierarchy will be used.

Secondly, we define an implementation for our multimethod using the `defmethod` form:

[source, clojure]</screen>
<simpara>(defmethod stringify-shape :box
  [_]
  "A box shape")</simpara>
<simpara>(defmethod stringify-shape :shape
  [_]
  "A generic shape")</simpara>
<simpara>(defmethod stringify-shape :default
  [_]
  "Unexpected object")</simpara>
<screen>Now, let's see what happens if we execute that function with a box:

[source, clojure]</screen>
<simpara>(stringify-shape :box)
;; &#8658; "A box shape"</simpara>
<screen>Now everything works as expected; the multimethod executes the direct matching implementation
for the given parameter. Next, let's see what happens if we execute the same function but with the `:circle`
keyword as the parameter, which does not have the direct matching dispatch value:

[source, clojure]</screen>
<simpara>(stringify-shape :circle)
;; &#8658; "A generic shape"</simpara>
<screen>The multimethod automatically resolves it using the provided hierarchy, and since `:circle` is
a descendant of `:shape`, the `:shape` implementation is executed.


=== Data types

Until, now, we have used maps, sets, lists and vectors to represent our data. And in most cases, this is a
really great approach. But sometimes we need to define our own types, and in this book we will
call them *datatypes*.

A datatype provides the following:

* A unique host-backed type, either named or anonymous.
* The ability to implement protocols (inline).
* Explicitly declared structure using fields or closures.
* Map like behavior (via records, see below).


==== Deftype

The most low level construction in _ClojureScript_ for creating your own types is the `deftype` macro. As a
demonstration, we will define a type called `User`:

[source, clojure]</screen>
<simpara>(deftype User [firstname lastname])</simpara>
<screen>Once the type has been defined, we can create an instance of our `User`. In the
following example, the `.` after `User` indicates that we are calling a constructor.

[source, clojure]</screen>
<simpara>(def person (User. "Triss" "Merigold"))</simpara>
<screen>And its fields can be accessed using the prefix-dot notation:

[source, clojure]</screen>
<simpara>(.-firstname person)
;; &#8658; "Triss"</simpara>
<screen>Types defined with `deftype` (and `defrecord`, which we will see later) creates a host-backed class-like object
associated with the current namespace. But it has some peculiarities when we intend to use or import
it from another namespace. The types in _ClojureScript_ should be imported with the `:import` directive
of the `ns` macro:

[source, clojure]</screen>
<simpara>(ns myns.core
  (:import otherns.User))</simpara>
<simpara>(User. "Cirilla" "Fiona")</simpara>
<screen>For convenience, _ClojureScript_ also defines a constructor function caled `-&gt;User` that can be imported
in the common way using the `:require` directive.

We personally do not like this type of function, and we prefer to define our own constructors, with more
idiomatic names:

[source, clojure]</screen>
<simpara>(defn make-user
  [firstname lastname]
  (User. firstname lastname))</simpara>
<screen>And use it in our code instead of `-&gt;User`.


==== Defrecord

The record is a slightly higher level abstraction for defining types in _ClojureScript_ and should be
preferred way to do it.

As we know, _ClojureScript_ tends to use plain data types such as maps, but in most cases we need
a named type to represent the entities of our application. Here come the records.

A record is a datatype that implements the map protocol and therefore can be used like any other map.
And since records are also proper types, they support type-based polymorphism through protocols.

In summary: with records, we have the best of both worlds, maps that can play in different
abstractions.

Let start defining the `User` type but using records:

[source, clojure]</screen>
<simpara>(defrecord User [firstname lastname])</simpara>
<screen>It looks really similar to the `deftype` syntax; in fact, it uses `deftype` behind the scenes as a low level
primitive for defining types.

Now, look at the difference with raw types for access to its fields:

[source, clojure]</screen>
<simpara>(def person (User. "Yennefer" "of Vengerberg"))</simpara>
<simpara>(:firstname user)
;; &#8658; "Yennefer"</simpara>
<simpara>(get person :firstname)
;; &#8658; "Yennefer"</simpara>
<screen>As we mentioned previously, records are maps and act like tham:

[source, clojure]</screen>
<simpara>(map? person)
;; &#8658; true</simpara>
<screen>And like maps, tham support extra fields that are not initially defined:

[source, clojure]</screen>
<simpara>(def person2 (assoc person :age 92))</simpara>
<simpara>(:age person2)
;; &#8658; 92</simpara>
<screen>As we can see, the `assoc` function works as expected and returns a new instance of the same
type but with new key value pair. But take care with `dissoc`! Its behavior with records is slightly
different than with maps; it will return a new record if the field being dissociated is an optional
field, but it will return a plain map if you dissociate a mandatory field.

An other difference with maps is that records do not act like functions:

[source, clojure]</screen>
<simpara>(def plain-person {:firstname "Yennefer", :lastname "of Vengerberg"})</simpara>
<simpara>(plain-person :firstname)
;; &#8658; "Yennefer"</simpara>
<simpara>(person :firstname)
;; &#8658; person.User does not implement IFn protocol.</simpara>
<screen>For convenience, the `defrecord` macro, like `deftype`, exposes a `-&gt;User` function, as well as an additional
`map-&gt;User` constructor function. We have the same opinion about that constructor as with
`deftype` defined ones: we recommend defining your own instead of using the other ones. But as they exist, let’s see
how they can be used:

[source, clojure]</screen>
<simpara>(def cirilla (&#8594;User "Cirilla" "Fiona"))
(def yen (map&#8594;User {:firstname "Yennefer"
                     :lastname "of Vengerberg"}))</simpara>
<screen>==== Implementing protocols

Both type definition primitives that we have seen so far allow inline implementations for protocols
(explained in a previous section). Let's define one for example purposes:

[source, clojure]</screen>
<simpara>(defprotocol IUser
  "A common abstraction for working with user types."
  (full-name [_] "Get the full name of the user."))</simpara>
<screen>Now, you can define a type with inline implementation for an abstraction, in our case the `IUser`:

[source, clojure]</screen>
<simpara>(defrecord User [firstname lastname]
  IUser
  (full-name [_]
    (str firstname " " lastname)))</simpara>
<variablelist>
<varlistentry>
<term></term>
<listitem>
<simpara>Create an instance.
(def user (User. "Yennefer" "of Vengerberg"))</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>(full-name user)
;; &#8658; "Yennefer of Vengerberg"</simpara>
<screen>==== Reify

The `reify` macro lets you create an anonymous type that implements protocols. In contrast to
`deftype` and `defrecord`, it does not have accessible fields.

This is  how we can emulate an instance of the user type that plays well with the `IUser` abstraction:

[source, clojure]</screen>
<simpara>(defn user
  [firstname lastname]
  (reify
    IUser
    (full-name [_]
      (str firstname " " lastname))))</simpara>
<simpara>(def yen (user "Yennefer" "of Vengerberg"))
(full-name user)
;; &#8658; "Yennefer of Vengerberg"</simpara>
<screen>The real purpose of `reify` is to create an anonymous type that may implement protocols,
but you don't want the type itself.


=== Host interoperability

_ClojureScript_, in the same way as it brother Clojure, is designed to be a "Guest" language. This means
that the design of the language works well on top of an existing ecosystem such as JavaScript
for _ClojureScript_ and the JVM for _Clojure_.


==== The types.

_ClojureScript_ unlike what you might expect, tries to take advantage of every type that the platform provides. This
is a (perhaps incomplete) list of things that _ClojureScript_ inherits and reuses from the underlying
platform:

* _ClojureScript_ strings are javascript *Strings*.
* _ClojureScript_ numbers are javascript *Numbers*.
* _ClojureScript_ `nil` is a javascript *null*.
* _ClojureScript_ regular expressions are javascript `RegExp` instances.
* _ClojureScript_ is not interpreted; it is always compiled down to JavaScript.
* _ClojureScript_ allows easy call to platform APIs with the same semantics.
* _ClojureScript_ data types internally compile to objects in JavaScript.

On top of it, _ClojureScript_ builds its own abstractions and types that do not exist in the
platform, such as Vectors, Maps, Sets, and others that are explained in previous sections of this chapter.


==== Interacting with platform types

_ClojureScript_ comes with a little set of special forms that allows it interact with platform
types such as calling object methods, creating new instances, and accessing object
properties.


===== Access to the platform

_ClojureScript_ has a special syntax for access to the entire platform environment through the
`js/` special namespace. This is an example of an expression to execute JavaScript's
built-in `parseInt` function:

[source, clojure]</screen>
<simpara>(js/parseInt "222")
;; &#8658; 222</simpara>
<screen>===== Creating new instances

_ClojureScript_ has two ways to create instances:

.Using the `new` special form
[source, clojure]</screen>
<simpara>(new js/RegExp "^foo$")</simpara>
<screen>Using the `.` special form
[source, clojure]</screen>
<simpara>(js/RegExp. "^foo$")</simpara>
<screen>The last one is the recommended way to create instances. We are not aware of real differences
between the two forms, but in the ClojureScript community the last one is used most often.


===== Invoke instance methods

To invoke methods of some object instance, as opposed to how it is done in JavaScript (e.g.,
`obj.method()`, the method name comes first like any other standard function in Lisp languages
but with a little variation: the function name starts with special form `.`.

Let's see how we can call the `.test()` method of a regexp instance:

[source, clojure]</screen>
<simpara>(def re (js/RegExp "^Clojure"))</simpara>
<simpara>(.test re "ClojureScript")
;; &#8658; true</simpara>
<screen>===== Access to object properties

Access to the object properties is really very similar to calling a method. The difference is that
instead of using the `.` you use `.-`. Let's see an example:

[source, clojure]</screen>
<simpara>(.-multiline re)
;; &#8658; false
(.-PI js/Math)
;; &#8658; 3.141592653589793</simpara>
<screen>===== JavaScript objects

_ClojureScript_ has different ways to create plain JavaScript objects, each one has its own
purpose. The basic one is the `js-obj` function. It accepts a variable number of pairs of keys and
values and returns a JavaScript object:

[source, clojure]</screen>
<simpara>(js-obj "country" "FR")
;; &#8658; #js {:country "FR"}</simpara>
<screen>The return value can be passed to some kind of third party library that accepts a plain
JavaScript object, but you can observe the real representation of the return value of this
function. It is really another other form for doing the same thing.

Using the reader macro `#js` consists of prepending it to a ClojureScript map or vector, and the
result will be transformed to plain JavaScript:

[source, clojure]</screen>
<simpara>(def myobj #js {:country "FR"})</simpara>
<screen>The translation of that to plain javascript is similar to this:

[source, javascript]</screen>
<simpara>var myobj = {country: "FR"};</simpara>
<screen>As explained in previous section, you also can access to the plain object properties using
the `.-` syntax:

[source, clojure]</screen>
<simpara>(.-country myobj)
;; &#8658; "FR"</simpara>
<screen>And as JavaScript objects are mutable, you can set a new value for some property using
the `set!` function:

[source, clojure]</screen>
<simpara>(set! (.-country myobj) "KR")</simpara>
<screen>===== Conversions

The inconvenience of the previously explained forms is that they does not make recursive
transformations, so if you have nested objects, the nested objects will not be converted.
To solve that use cases _ClojureScript_ comes with the `clj-&gt;js` and `js-&gt;clj` functions
that transform clojure collection types into JavaScript and back:

[source, clojure]</screen>
<simpara>(clj&#8594;js {:foo {:bar "baz"}})
;; &#8658; #js {:foo #js {:bar "baz"}}</simpara>
<screen>In case of arrays, there is a specialized function `into-array` that behaves as expected:

[source, clojure]</screen>
<simpara>(into-array ["France" "Korea" "Peru"])
;; &#8658; #js ["France" "Korea" "Peru"]</simpara>
<screen>===== Arrays

In previous example we have seen how we can create an array from an existing _ClojureScript_
collection. But there is another function for creating arrays: `make-array`.

.Creating a preallocated array with length 10
[source, clojure]</screen>
<simpara>(def a (make-array 10))
;; &#8658; #js [nil nil nil nil nil nil nil nil nil nil]</simpara>
<screen>In _ClojureScript_ arrays also play well with sequence abstractions so you can iterate
over them or simply get the number of elements with the `count` function:

[source, clojure]</screen>
<simpara>(count a)
;; &#8658; 10</simpara>
<screen>As arrays on the JavaScript platform are a mutable collection type, you can access a concrete index
and set the value at that position:

[source, clojure]</screen>
<simpara>(aset a 0 2)
;; &#8658; 2
a
;; &#8658; #js [2 nil nil nil nil nil nil nil nil nil]</simpara>
<screen>Or access in a indexed way to get its values:

[source, clojure]</screen>
<simpara>(aget a 0)
;; &#8658; 2</simpara>
<screen>In JavaScript, objects are also arrays, so you can use the same functions for interacting
with plain objects:

[source, clojure]</screen>
<simpara>(def b #js {:hour 16})
;; &#8658; #js {:hour 16}</simpara>
<simpara>(aget b "hour")
;; &#8658; 16</simpara>
<simpara>(aset b "minute" 22)
;; &#8658; 22</simpara>
<simpara>b
;; &#8658; #js {:hour 16, :minute 22}</simpara>
<screen>=== State management

TBD

anchor:truthiness-section[]
=== Truthiness

This is the aspect where each language has its own semantics. The majority of languages
consider empty collections, the integer 0, and other things like this to be false.
In _ClojureScript_, unlike in other languages, only two values are considered as false: `nil`
and `false`, Everything else is treated as `true`.

So, thanks to this, sets can be also be considered as predicates. If a set returns a value, it exists,
and if it returns `nil` the value does not exist:

[source, clojure]</screen>
<simpara>(def s #{1 2})</simpara>
<simpara>(s 1)
;; &#8658; 1</simpara>
<simpara>(s 3)
;; &#8658; nil</simpara>
<screen>=== Transducers

TBD


=== Transients

TBD


=== Metadata

TBD


=== A little overview of macros

TBD


== Tooling &amp; Compiler

This chapter will cover a little introduction to existing tooling for making things easy when
developing using ClojureScript. It will cover:

* Using the repl
* Leiningen and cljsbuild
* Google Closure Library
* Modules
* Unit testing
* Library development
* Browser based development
* Server based development

Unlike the previous chapter, this chapter intends to tell different stories each independent of each other.

=== Getting Started with the ClojureScript compiler

At this point, you are surely very bored with the constant theoretical explanations about the language
itself and will want to write and execute some code. The goal of this section is to provide a little practical
introduction to the _ClojureScript_ compiler.

The _ClojureScript_ compiler takes the source code that has been split over numerous directories and namespaces and
compiles it down to JavaScript. Today, JavaScript has great number of different environments
where it can be executed - each with its own pecularities.

This chapter intends to explain how to use _ClojureScript_ without any additional tooling. This
will help you understand how the compiler works and how you can use it when other tooling is not
available (such as link:http://leiningen.org/[leiningen] + link:https://github.com/emezeske/lein-cljsbuild[cljsbuild]
or link:http://boot-clj.com/[boot]).


==== Execution environments

What is an execution environment? An execution environment is an engine where JavaScript can be
executed. For example, the most popular execution environment is a browser (Chrome, Firefox, ...)
followed by the second most popular - link:https://nodejs.org/[nodejs]/link:https://iojs.org/en/index.html[iojs].

There are others, such as Rhino (JDK 6+), Nashorn (JDK 8), QtQuick (QT),... but none of them have
significant differences from the first two. So, _ClojureScript_ at the moment may compile
code to run in the browser or in nodejs/iojs like environments out of the box.


==== Download the compiler

The _ClojureScript_ compiler is implemented in Java, and to use it, you should have jdk8 installed.
_ClojureScript_ itself only requires JDK 7, but the standalone compiler that we going to use in this
chapter requires JDK 8, which can be found at http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html

You can download it using `wget`:

[source, bash]</screen>
<simpara>wget <ulink url="https://github.com/clojure/clojurescript/releases/download/r3269/cljs.jar">https://github.com/clojure/clojurescript/releases/download/r3269/cljs.jar</ulink></simpara>
<screen>The _ClojureScript_ compiler is packaged in a standalone executable jar file, so this is the only
file (along with JDK 8) that you need to compile your _ClojureScript_ source code to JavaScript.


==== Compile for nodejs/iojs

Let’s start with a practical example compiling code that will target *nodejs*/*iojs*. For
this example you should have nodejs or iojs (recommended) installed.

There are different ways to install iojs, but the recommended way is using nvm (node version
manager). You can read the instructions to install and use nvm at: https://github.com/creationix/nvm[home page].

You can test if *iojs* is installed in your system with this command:

[source, shell]</screen>
<simpara>$ iojs --version
v2.1.0</simpara>
<screen>===== Create the example application

For the first step of our practical example, we will create our application directory structure
and populate it with example code.

Start by creating the directory tree structure for our “hello world” application:

[source, bash]</screen>
<simpara>mkdir -p src/myapp
touch src/myapp/core.cljs</simpara>
<screen>Second, write the example code into the previously created `src/myapp/core.cljs` file:

[source, clojure]</screen>
<simpara>(ns myapp.core
  (:require [cljs.nodejs :as nodejs]))</simpara>
<simpara>(nodejs/enable-util-print!)</simpara>
<simpara>(defn -main
  [&amp; args]
  (println "Hello world!"))</simpara>
<simpara>(set! <emphasis role="strong">main-cli-fn</emphasis> -main)</simpara>
<screen>NOTE: It is very important that the declared namespace in the file exactly matches the directory
structure. This is the way _ClojureScript_ structures its source code.


===== Compile the example application

In order to compile that source code, we need a simple build script that tells the
_ClojureScript_ compiler the source directory and the output file. _ClojureScript_ has a
lot of other options, but at this moment we can ignore that.

Let’s create the _build.clj_ file with the following content:

[source, clojure]</screen>
<simpara>(require 'cljs.closure)</simpara>
<simpara>(cljs.closure/build "src"
 {:output-to "main.js"
  :main 'myapp.core
  :target :nodejs})</simpara>
<screen>This is a brief explanation of the compiler options used in this example:

* The `:output-to` parameter indicates to the compiler the destination of the compiled code, in this
  case to the "main.js" file.
* The `:main` property indicates to the compiler the namespace that will act as the entry point of
  your application when it's executed.
* The `:target` property indicates the platform where you want execute the compiled code. In this case
  we are going to use *iojs* (formerly nodejs). If you omit this parameter, the source will be
  compiled to run in the browser environment.

To run the compilation, just execute the following command:

[source, bash]</screen>
<simpara>java -cp cljs.jar:src clojure.main build.clj</simpara>
<screen>And when it finishes, execute the compiled file using *iojs*:

[source, shell]</screen>
<simpara>$ iojs main.js
Hello world!</simpara>
<screen>==== Compile for the Browser

In this section we are going to create an application similar to the "hello world" example from the
previous section to run in the browser environment. The minimal requirement for this application
is just a browser that can execute JavaScript.

The process is almost the same, and the directory structure is the same. The only things that
changes is the entry point of the application and the build script. So, start re-creating
the directory tree from previous example in a different directory.

Then, write new content to the `src/myapp/core.cljs` file:

[source, clojure]</screen>
<simpara>(ns myapp.core)</simpara>
<simpara>(enable-console-print!)</simpara>
<simpara>(println "Hello world!")</simpara>
<screen>In the browser environment we do not need a specific entry point for the application,
so the entry point is the entire namespace.


===== Compile the example application

In order to compile the source code to run properly in a browser, overwrite
the _build.clj_ file with the following content:

[source, clojure]</screen>
<simpara>(require 'cljs.closure)</simpara>
<simpara>(cljs.closure/build "src"
 {:output-to "main.js"
  :output-dir "out/"
  :source-map "main.js.map"
  :main 'myapp.core
  :optimizations :none})</simpara>
<screen>This is a brief explanation of the compiler options we're using:

* The `:output-to` parameter indicates to the compiler the destination of the compiled code, in this
  case the "main.js" file.
* The `:main` property indicates to the compiler the namespace that will act as the entry point of
  your application when it's executed.
* `:source-map` indicates the destination of the source map. (The source map connects the ClojureScript source
  to the generated JavaScript so that error messages can point you back to the original source.)
* `:output-dir` indicates the destination directory for all files sources used in a compilation. It is
  just for making source maps work properly with the rest of code, not only your source.
* `:optimizations` indicates the compilation optimization. There are different values for this option,
  but that will be covered in following sections in more detail.

To run the compilation, just execute the following command:

[source, bash]</screen>
<simpara>java -cp cljs.jar:src clojure.main build.clj</simpara>
<screen>This process can take some time, so do not worry; wait a little bit. The JVM bootstrap with Clojure
compiler is slightly slow. In the following sections we will explain how to start a watch process to avoid
constantly starting and stopping this slow process.

While waiting for the compilation, let's create a dummy HTML file to make it easy to execute our example
app in the browser. Create the _index.html_ file with the following content; it goes in the main _myapp_
directory.

[source, html]</screen>
<simpara>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;header&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Hello World from ClojureScript&lt;/title&gt;
  &lt;/header&gt;
  &lt;body&gt;
    &lt;script src="main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</simpara>
<screen>Now, when the compilation finishes and you have the basic HTML file you can just open it with your favorite
browser and take a look in the development tools console. The "Hello world!" message should appear there.


==== Watch process

Surely, you have already experienced the slow startup of the _ClojureScript_ compiler. To solve this,
the _ClojureScript_ standalone compiler also comes with tools to start a process that watches the changes
in some directory and performs an incremental compilation.

Start creating another build script, but in this case name it _watch.clj_:

[source, clojure]</screen>
<simpara>(require 'cljs.closure)</simpara>
<simpara>(cljs.closure/watch "src"
 {:output-to "main.js"
  :output-dir "out/"
  :source-map "main.js.map"
  :main 'myapp.core
  :optimizations :none})</simpara>
<screen>Now, execute that script like any other that you have executed in previous sections:

[source, bash]</screen>
<simpara>$ java -cp cljs.jar:src clojure.main watch.clj
Building &#8230;&#8203;
Reading analysis cache for jar:file:/home/niwi/cljsbook/playground/cljs.jar!/cljs/core.cljs
Compiling out/cljs/core.cljs
Using cached cljs.core out/cljs/core.cljs
&#8230;&#8203; done. Elapsed 0.8354759 seconds
Watching paths: /home/niwi/cljsbook/playground/src</simpara>
<simpara>Change detected, recompiling &#8230;&#8203;
Compiling src/myapp/core.cljs
Compiling out/cljs/core.cljs
Using cached cljs.core out/cljs/core.cljs
&#8230;&#8203; done. Elapsed 0.191963443 seconds</simpara>
<screen>You can observe that in the second compilation, the time is drastically reduced. Another advantage
of this method is that it is a gives a little bit more output.


==== Optimization levels

The _ClojureScript_ compiler has different level of optimizations. Behind the scenes, those compilation
levels are coming from Google Closure Compiler.

A very simplified overview of the compilation process is:

1. The reader reads the code and makes some analysis. This process can raise some warnings
   during this phase.
2. Then, the _ClojureScript_ compiler emits JavaScript code. The result is one JavaScript
   file for each cljs file.
3. The generated files passes through the Closure Compiler that, depending on the optimization level
   and other options (sourcemaps, output dir output to, ...) generates the final output.

The final output depends strictly on the optimization level.


===== none

Implies that closure compiler just writes the files as is, without any additional
optimization applied to the source code. This optimization level is mandatory if you are targeting
*nodejs* or *iojs* and is appropiate in development mode when your code targets the browser.


===== whitespace

This optimization level consists of concatenating the compiled files in an appropriate order, removing
line breaks and other whitespace and generating the output as one large file.

It also has some compilation speed penalty, resulting in slower compilations. In any case, it is not
terribly slow and is completely usable in small/medium applications.


===== simple

The simple compilation level implies (includes) all transformations from whitespace optimization and
additionally performs optimizations within expressions and functions, including renaming local variables
and function parameters to shorter names.

Compilation with the `:simple` optimization always preserves the functionality of syntactically valid
JavaScript, so it does not interfere with the interaction between the compiled _ClojureScript_ and
other JavaScript.


===== advanced

TBD


=== Working with the REPL

////
TODO: maybe would be interesting take some ideas from http://www.alexeberts.com/exploring-the-clojurescript-repl/
////

==== Introduction

Although you can create a source file and compile it every time you want to try something out in
ClojureScript, it's easier to use the REPL. REPL stands for:

* Read - get input from the keyboard
* Evaluate the input
* Print the result
* Loop back for more input

In other words, the REPL lets you try out ClojureScript concepts and get immediate feedback.

_ClojureScript_ comes with support for executing the REPL in different execution environments,
each one has its own advantages or disadvantages. For example, you can run a REPL in a nodejs
but in that environment you don't have access to the dom.

In summary: everthing really depends on your needs or requirements.


==== Nashorn REPL

The Nashorn REPL is the easiest and maybe most painless REPL environment because it does not require any
special stuff, just the JVM (JDK 8) that you have used in previous examples for running the
_ClojureScript_ compiler.

Let’s start creating the _repl.clj_ file with following content:

[source, clojure]</screen>
<simpara>(require '[cljs.repl]
         '[cljs.repl.nashorn])</simpara>
<simpara>(cljs.repl/repl
 (cljs.repl.nashorn/repl-env)
 :output-dir "out"
 :cache-analysis true)</simpara>
<screen>Them, execute the following command to get the REPL up and running:

[source, bash]</screen>
<simpara>$ java -cp cljs.jar:src clojure.main repl.clj
To quit, type: :cljs/quit
cljs.user&#8658; (+ 1 2)
3</simpara>
<screen>You may have noticed that the REPL does not have support for history and other shell-like facilities. This
is because the default REPL does not comes with "readline" support. But this problem can be solved using
the simple tool called `rlwrap` that you can certainly find with the package manager of your operating system.

The `rlwrap` makes the REPL "readline" capable and will allow you to have command history, code navigation,
and other shell-like utilities that will make your REPL experience much more pleasant. To use it, just
prepend it to the previous command that we have used to execute the REPL:

[source, bash]</screen>
<simpara>$ rlwrap java -cp cljs.jar:src clojure.main repl.clj
To quit, type: :cljs/quit
cljs.user&#8658; (+ 1 2)
3</simpara>
<screen>==== Node REPL

This REPL uses a nodejs/iojs as execution environment, and obviously requires that nodejs or iojs will
be installed in your system.

Surelly you are asking yourself, why I need a repl with nodejs when we have nashorn that does not requires
any additional dependencies. The answer is very simple, node/iojs is the most used javascript execution
environment on backend and it has a great amount of community packages around it.

Well, the good notice is that start nodejs/iojs repl is very very easy once you have it installed in
your system. Start writing this content to a new `repl.clj` file:

[source, clojure]</screen>
<simpara>(require '[cljs.repl]
         '[cljs.repl.node])</simpara>
<simpara>(cljs.repl/repl
 (cljs.repl.node/repl-env)
 :output-dir "out"
 :cache-analysis true)</simpara>
<screen>And start the REPL like you have done it previously with nashorn REPL:

[source,bash]</screen>
<simpara>$ rlwrap java -cp cljs.jar:src clojure.main repl.clj
To quit, type: :cljs/quit
cljs.user&#8658; (+ 1 2)
3</simpara>
<screen>==== Browser REPL

This REPL is the most laborious to get it up and running. This is because it uses a browser for
its execution environment and it has additional requirements.

Let’s start by creating a file named `brepl.clj` with the following content:

[source, clojure]</screen>
<simpara>(require 'cljs.repl)
(require 'cljs.closure)
(require 'cljs.repl.browser)</simpara>
<simpara>(cljs.closure/build
 "src"
 {:output-to "main.js"
  :output-dir "out/"
  :source-map "main.js.map"
  :main 'myapp.core
  :optimizations :none})</simpara>
<simpara>(cljs.repl/repl
 (cljs.repl.browser/repl-env)
 :watch "src"
 :output-dir "out/")</simpara>
<screen>This script builds the source, just as we did earlier, and then starts the REPL.

But the browser REPL also requires that some code be executed in the browser before getting the
REPL working. To do that, just re-create the application structure very similar to the one
that we have used in previous sections:

[source, bash]</screen>
<simpara>mkdir -p src/myapp
touch src/myapp/core.cljs</simpara>
<screen>Then, write new content to the `src/myapp/core.cljs` file:

[source, clojure]</screen>
<simpara>(ns myapp.core
 (:require [clojure.browser.repl :as repl]))</simpara>
<simpara>(defonce conn
  (repl/connect "http://localhost:9000/repl"))</simpara>
<simpara>(enable-console-print!)</simpara>
<simpara>(println "Hello, world!")</simpara>
<screen>And finally, create the missing _index.html_ file that is going to be used as the entry point
for running the browser side code of the REPL:

[source, html]</screen>
<simpara>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;header&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Hello World from ClojureScript&lt;/title&gt;
  &lt;/header&gt;
  &lt;body&gt;
    &lt;script src="main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</simpara>
<screen>Well, that was a lot of setup! But trust us, it’s all worth it when you see it in action. To do that,
just execute the `brepl.clj` in same way that we have done it in previous examples:

[source, bash]</screen>
<simpara>$ rlwrap java -cp cljs.jar:src clojure.main brepl.clj
Compiling client js &#8230;&#8203;
Waiting for browser to connect &#8230;&#8203;</simpara>
<screen>And finally, open your favourite browser and go to http://localhost:9000/. Once the page
is loaded (the page will be blank), switch back to the console where you have run the REPL
and you will see that it is up and running:

[source, bash]</screen>
<simpara>Watch compilation log available at: out/watch.log
To quit, type: :cljs/quit
cljs.user&#8658; (+ 14 28)
42</simpara>
<screen>One of the big advantages of this REPL is that you have access to all the browser environment. To
demonstrate it, just enter `(js/alert "hello world")` in the repl. The result of that will be
the typical browser alert dialog.


=== Build and Dependency management tools

Until now, we have used the builtin _ClojureScript_ toolchain for compile our sources to javascript,
and it is ok for start using it and understand how it works. But it is not very comfortable for use
for big projects with dependencies to third party libraries.

This chapter intends to explain how you can use *Leiningen*, the defacto clojure build and dependency
management tool for build _ClojureScript_ projects. It there an other growing in popularity build tool
called *boot* but at this momenent it will not to be covered in this book.


==== Installing leiningen

The installation process of leiningen is quite simple, just follow this steps:

[source, bash]</screen>
<simpara>mkdir ~/bin
cd ~/bin
wget <ulink url="https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein">https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein</ulink>
chmod a+x ./lein
export PATH=$PATH:~/bin</simpara>
<screen>Make sure that the `~/bin` directory is always set on your path, so for make it permanent, add the
line of export to your `~/.bashrc` file (we are supposing that you are using bash shell).

And now, open another clean terminal and execute `lein version`:

[source, bash]</screen>
<simpara>$ lein version
Leiningen 2.5.1 on Java 1.8.0_45 OpenJDK 64-Bit Server VM</simpara>
<screen>NOTE: We are supposing that you are using Unix like system such as Linux or BSD, if you are
windows user, please check the instructions on the link:http://leiningen.org/[Leiningen homepage].


==== First project

TBD


=== The Closure Library

TBD


=== Browser based development

TBD

//^ A little guide and notes about implications of developing for web
//^ environments (optimizations, third party libraries, modularization, ...)

==== Using third party JavaScript libraries

TBD


====  Modularizing your code

//^ Mainly related to google closure modules and slightly related to web based development
//^ Maybe this is not the chapter for this section.

TBD



=== Developing a library

//^ A little guide and implications of developing a library for clojurescript.

TBD


=== Unit testing

TBD


== Mixed Bag

This chapter will cover miscellaneous topics that are not classified in the previous ones. This is a
"catchall" section and will touch a bunch of heterogeneus topics like:

* Async primitives using the _core.async_ library.
* Working with promises.
* Error handling using the _cats_ library.
* Pattern matching with the _core.match_ library.
* Web development using the Om library.
* Share code between clojure and clojurescript.

=== Async primitives using core.async.

TBD

=== Working with promises.

TBD


=== Error handling using monads and Cats.

TBD


=== Pattern matching using core.match.

TBD


=== Web development with Om and React.

TBD


=== Writing libraries that shares code between Clojure and ClojureScript.

TBD

//^ This chapter can grow as we like with different dispare themes ;)</screen>
</section>
</section>
</section>
</chapter>
</book>